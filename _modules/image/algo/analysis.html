<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>image.algo.analysis &mdash; OpenAlea community website</title>
    
    <link rel="stylesheet" href="../../../_static/virtualplants.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenAlea community website" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">OpenAlea community website</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for image.algo.analysis</h1><div class="highlight"><pre>
<span class="c"># -*- python -*-</span>
<span class="c">#</span>
<span class="c">#       OpenAlea.Image</span>
<span class="c">#</span>
<span class="c">#       Copyright 2006 - 2012 INRIA - CIRAD - INRA</span>
<span class="c">#</span>
<span class="c">#       File author(s): Eric MOSCARDI &lt;eric.moscardi@sophia.inria.fr&gt;</span>
<span class="c">#                       Jonathan LEGRAND &lt;jonathan.legrand@ens-lyon.fr&gt;</span>
<span class="c">#                       Frederic BOUDON &lt;frederic.boudon@cirad.fr&gt;</span>
<span class="c">#</span>
<span class="c">#       Distributed under the Cecill-C License.</span>
<span class="c">#       See accompanying file LICENSE.txt or copy at</span>
<span class="c">#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html</span>
<span class="c">#</span>
<span class="c">#       OpenAlea WebSite : http://openalea.gforge.inria.fr</span>
<span class="c">################################################################################</span>

<span class="n">__license__</span> <span class="o">=</span> <span class="s">&quot;Cecill-C&quot;</span>
<span class="n">__revision__</span> <span class="o">=</span> <span class="s">&quot; $Id$ &quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">gzip</span><span class="o">,</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="kn">as</span> <span class="nn">nd</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">svd</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">exists</span><span class="p">,</span> <span class="n">splitext</span>

<span class="kn">from</span> <span class="nn">openalea.image.spatial_image</span> <span class="kn">import</span> <span class="n">SpatialImage</span>
<span class="kn">from</span> <span class="nn">openalea.plantgl.math</span> <span class="kn">import</span> <span class="n">Vector3</span>


<div class="viewcode-block" id="dilation"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.dilation">[docs]</a><span class="k">def</span> <span class="nf">dilation</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function dilating slices: extend the boundingbox of one voxel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span> <span class="p">]</span>

</div>
<div class="viewcode-block" id="dilation_by"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.dilation_by">[docs]</a><span class="k">def</span> <span class="nf">dilation_by</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function dilating slices: extend the boundingbox of one voxel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="n">amount</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="o">+</span><span class="n">amount</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span> <span class="p">]</span>

</div>
<div class="viewcode-block" id="wall"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.wall">[docs]</a><span class="k">def</span> <span class="nf">wall</span><span class="p">(</span><span class="n">mask_img</span><span class="p">,</span> <span class="n">label_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_img</span> <span class="o">==</span> <span class="n">label_id</span><span class="p">)</span>
    <span class="n">dil</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">contact</span> <span class="o">=</span> <span class="n">dil</span> <span class="o">-</span> <span class="n">img</span>
    <span class="k">return</span> <span class="n">mask_img</span><span class="p">[</span><span class="n">contact</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="contact_surface"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.contact_surface">[docs]</a><span class="k">def</span> <span class="nf">contact_surface</span><span class="p">(</span><span class="n">mask_img</span><span class="p">,</span> <span class="n">label_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">wall</span><span class="p">(</span><span class="n">mask_img</span><span class="p">,</span><span class="n">label_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="real_indices"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.real_indices">[docs]</a><span class="k">def</span> <span class="nf">real_indices</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">resolutions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span><span class="n">resolutions</span><span class="p">)</span> <span class="p">]</span>

</div>
<div class="viewcode-block" id="hollow_out_cells"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.hollow_out_cells">[docs]</a><span class="k">def</span> <span class="nf">hollow_out_cells</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">remove_background</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Laplacian filter used to dectect and return an Spatial Image containing only cell walls.</span>
<span class="sd">    (The Laplacian of an image highlights regions of rapid intensity change.)</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `image` (SpatialImage) - Segmented image (tissu).</span>
<span class="sd">     - `background` (int) - label representing the background (to remove).</span>

<span class="sd">    :Return:</span>
<span class="sd">     - `m` (SpatialImage) - Spatial Image containing hollowed out cells (only walls).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Hollowing out cells... &#39;</span><span class="p">,</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">laplace</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">b</span><span class="o">!=</span><span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">image</span> <span class="o">*</span> <span class="n">mask</span>
    <span class="k">if</span> <span class="n">remove_background</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">m</span><span class="o">!=</span><span class="n">background</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">mask</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Done !!&#39;</span>
    <span class="k">return</span> <span class="n">m</span>

</div>
<div class="viewcode-block" id="sort_boundingbox"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.sort_boundingbox">[docs]</a><span class="k">def</span> <span class="nf">sort_boundingbox</span><span class="p">(</span><span class="n">boundingbox</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use this to determine which label as the smaller boundingbox !</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundingbox</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">boundingbox</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_1</span><span class="p">))</span> <span class="ow">and</span> <span class="n">boundingbox</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">label_2</span><span class="p">,</span> <span class="n">label_1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">boundingbox</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">boundingbox</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_2</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">boundingbox</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_1</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">boundingbox</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_2</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="n">bbox_1</span> <span class="o">=</span> <span class="n">boundingbox</span><span class="p">[</span><span class="n">label_1</span><span class="p">]</span>
    <span class="n">bbox_2</span> <span class="o">=</span> <span class="n">boundingbox</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span>
    <span class="n">vol_bbox_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">bbox_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">bbox_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">bbox_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">bbox_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">bbox_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">bbox_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
    <span class="n">vol_bbox_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">bbox_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">bbox_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">bbox_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">bbox_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">bbox_2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">bbox_2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span> <span class="k">if</span> <span class="n">vol_bbox_1</span><span class="o">&lt;</span><span class="n">vol_bbox_2</span> <span class="k">else</span> <span class="p">(</span><span class="n">label_2</span><span class="p">,</span> <span class="n">label_1</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="wall_voxels_between_two_cells"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.wall_voxels_between_two_cells">[docs]</a><span class="k">def</span> <span class="nf">wall_voxels_between_two_cells</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the voxels coordinates defining the contact wall between two labels.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `image` (ndarray of ints) - Array containing objects defined by labels</span>
<span class="sd">     - `label_1` (int) - object id #1</span>
<span class="sd">     - `label_2` (int) - object id #2</span>
<span class="sd">     - `bbox` (dict, optional) - If given, contain a dict of slices</span>

<span class="sd">    :Return:</span>
<span class="sd">     - xyz 3xN array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">sort_boundingbox</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
        <span class="n">boundingbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">label_1</span><span class="p">]</span>
        <span class="n">dilated_bbox</span> <span class="o">=</span> <span class="n">dilation</span><span class="p">(</span> <span class="n">boundingbox</span> <span class="p">)</span>
        <span class="n">dilated_bbox_img</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">dilated_bbox</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">boundingbox</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">max_label</span><span class="o">=</span><span class="nb">max</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]))</span>
            <span class="n">boundingbox</span> <span class="o">=</span> <span class="p">{</span><span class="n">label_1</span><span class="p">:</span><span class="n">boundingbox</span><span class="p">[</span><span class="n">label_1</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">label_2</span><span class="p">:</span><span class="n">boundingbox</span><span class="p">[</span><span class="n">label_2</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>
            <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">sort_boundingbox</span><span class="p">(</span><span class="n">boundingbox</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
            <span class="n">boundingbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">label_1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">dilated_bbox_img</span> <span class="o">=</span> <span class="n">image</span>

    <span class="n">mask_img_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">dilated_bbox_img</span> <span class="o">==</span> <span class="n">label_1</span><span class="p">)</span>
    <span class="n">mask_img_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">dilated_bbox_img</span> <span class="o">==</span> <span class="n">label_2</span><span class="p">)</span>

    <span class="n">struct</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">dil_1</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask_img_1</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct</span><span class="p">)</span>
    <span class="n">dil_2</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask_img_2</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">dil_1</span> <span class="o">&amp;</span> <span class="n">mask_img_2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dil_2</span> <span class="o">&amp;</span> <span class="n">mask_img_1</span><span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="walls_voxels_per_cell"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.walls_voxels_per_cell">[docs]</a><span class="k">def</span> <span class="nf">walls_voxels_per_cell</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">neighbors2ignore</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">background</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">try_to_use_neighbors2ignore</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the voxels coordinates of all walls from one cell. </span>
<span class="sd">    There must be a contact defined between two labels, the given one and its neighbors.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `image` (ndarray of ints) - Array containing objects defined by labels</span>
<span class="sd">     - `label_1` (int): cell id #1.</span>
<span class="sd">     - `bbox` (dict, optional) - dictionary of slices defining bounding box for each labelled object.</span>
<span class="sd">     - `neighbors` (list, optional) - list of neighbors for the object `label_1`.</span>
<span class="sd">     - `neighbors2ignore` (list, optional) - labels of neighbors to ignore while considering separation between the object `label_1` and its neighbors. All ignored labels will be returned as 0.</span>
<span class="sd">    :Return:</span>
<span class="sd">     - `coord` (dict): *keys= [min(labels_1,neighbors[n]), max(labels_1,neighbors[n])]; *values= xyz 3xN array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># -- We use the bounding box to work faster (on a smaller image)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">boundingbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">(</span><span class="n">label_1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span><span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">slice</span><span class="p">):</span>
        <span class="n">boundingbox</span> <span class="o">=</span> <span class="n">bbox</span>
    <span class="k">elif</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span> <span class="n">image</span><span class="p">,</span> <span class="n">max_label</span> <span class="o">=</span> <span class="n">label_1</span> <span class="p">)</span>
        <span class="n">boundingbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dilated_bbox</span> <span class="o">=</span> <span class="n">dilation</span><span class="p">(</span><span class="n">dilation</span><span class="p">(</span> <span class="n">boundingbox</span> <span class="p">))</span>
    <span class="n">dilated_bbox_img</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">dilated_bbox</span><span class="p">]</span>

    <span class="c"># -- Binary mask saying where the label_1 can be found on the image.</span>
    <span class="n">mask_img_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">dilated_bbox_img</span> <span class="o">==</span> <span class="n">label_1</span><span class="p">)</span>
    <span class="n">struct</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">dil_1</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask_img_1</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct</span><span class="p">)</span>

    <span class="c"># -- We edit the neighbors list as required:</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dilated_bbox_img</span><span class="p">)</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label_1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbors</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">neighbors</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">[</span><span class="n">label_1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">background</span> <span class="ow">in</span> <span class="n">neighbors2ignore</span><span class="p">:</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">background</span><span class="p">)</span> <span class="c"># We don&#39;t want the voxels coordinates with the background.</span>
        <span class="k">if</span> <span class="n">try_to_use_neighbors2ignore</span><span class="p">:</span>
            <span class="n">neighbors2ignore</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">background</span><span class="p">)</span> <span class="c"># And we don&#39;t want to replace it by &#39;0&#39; (fuse or group all voxels coordinates to an &quot;unlabelled&quot; set of points)</span>

    <span class="n">coord</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">neighbors_not_found</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
        <span class="c"># -- Binary mask saying where the label_2 can be found on the image.</span>
        <span class="n">mask_img_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">dilated_bbox_img</span> <span class="o">==</span> <span class="n">label_2</span><span class="p">)</span>
        <span class="n">dil_2</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask_img_2</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct</span><span class="p">)</span>
        <span class="c"># -- We now intersect the two dilated binary mask to find the voxels defining the contact area between two objects:</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">dil_1</span> <span class="o">&amp;</span> <span class="n">mask_img_2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dil_2</span> <span class="o">&amp;</span> <span class="n">mask_img_1</span><span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="n">label_2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbors2ignore</span><span class="p">:</span>
                <span class="n">coord</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span><span class="n">label_2</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span><span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">try_to_use_neighbors2ignore</span><span class="p">:</span> <span class="c"># in case we want to ignore the specific position of some neighbors we replace its id by &#39;0&#39;:</span>
                <span class="k">if</span> <span class="n">are_these_labels_neighbors</span><span class="p">(</span><span class="n">neighbors2ignore</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">):</span> <span class="c"># we check that all neighbors to ignore are themself a set of connected neighbors!</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">coord</span><span class="o">.</span><span class="n">has_key</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">label_1</span><span class="p">)):</span>
                        <span class="n">coord</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">label_1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">coord</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">label_1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span> <span class="p">(</span><span class="n">coord</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">label_1</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="n">dilated_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)))</span> <span class="p">)</span>
                <span class="c">#~ else:</span>
                    <span class="c">#~ coord[(0,label_1)] = None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbors_not_found</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;Couldn&#39;t find a contact between neighbor cells </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">label_1</span><span class="p">,</span> <span class="s">&quot;&amp; </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">label_2</span>
    <span class="k">if</span> <span class="n">neighbors_not_found</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Some neighboring cells have not been found !&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coord</span>

</div>
<div class="viewcode-block" id="cells_walls_coords"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.cells_walls_coords">[docs]</a><span class="k">def</span> <span class="nf">cells_walls_coords</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hollow_out</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return coordinates of the voxels belonging to the cell wall.</span>
<span class="sd">    </span>
<span class="sd">    .. warning :: Apply only to full 3D image, and not if only the first layer of voxel is provided (external envelope).</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - image (SpatialImage) - Segmented image (tissu)</span>

<span class="sd">    :Return:</span>
<span class="sd">     - x,y,z (list) - coordinates of the voxels defining the cell boundaries (walls).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hollow_out</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">hollow_out_cells</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">image</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">image</span><span class="o">==</span><span class="n">background</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">hollow_out</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Extracting cell walls coordinates...&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">image</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">image</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="cell_vertex_extraction"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.cell_vertex_extraction">[docs]</a><span class="k">def</span> <span class="nf">cell_vertex_extraction</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">hollow_out</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates cell&#39;s vertices positions according to the rule: a vertex is the point where you can find 4 differents cells (in 3D!!)</span>
<span class="sd">    For the surface, the outer &#39;cell&#39; #1 is considered as a cell.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - image (SpatialImage) - Segmented image (tissu). Can be a full spatial image or an extracted surface.</span>

<span class="sd">    :Return:</span>
<span class="sd">     - barycentric_vtx (dict) -</span>
<span class="sd">            *keys = the 4 cells ids associated with the vertex position(values);</span>
<span class="sd">            *values = 3D coordinates of the vertex in the Spatial Image;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">cells_walls_coords</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">hollow_out</span><span class="p">)</span>
    <span class="c">## Compute vertices positions by findind the voxel belonging to each vertex.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Compute cell vertex positions...&#39;</span>
    <span class="n">vertex_voxel</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">%</span><span class="mi">20000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">n</span><span class="p">,</span><span class="s">&#39;/&#39;</span><span class="p">,</span><span class="n">dim</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">sub_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">),(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">):(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">),(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)]</span> <span class="c"># we extract a sub part of the matrix...</span>
        <span class="n">sub_image</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sub_image</span><span class="p">))</span>
        <span class="c"># -- Now we detect voxels defining cells&#39; vertices.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_image</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">):</span> <span class="c"># ...in which we search for 4 different labels</span>
            <span class="k">if</span> <span class="n">vertex_voxel</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">sub_image</span><span class="p">):</span>
                <span class="n">vertex_voxel</span><span class="p">[</span><span class="n">sub_image</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">vertex_voxel</span><span class="p">[</span><span class="n">sub_image</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">)</span> <span class="c"># we group voxels defining the same vertex by the IDs of the 4 cells.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertex_voxel</span><span class="p">[</span><span class="n">sub_image</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="c">## Compute the barycenter of the voxels associated to each vertex (correspondig to the 3 cells detected previously).</span>
    <span class="n">barycentric_vtx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vertex_voxel</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">barycentric_vtx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vertex_voxel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Done !!&#39;</span>

    <span class="k">return</span> <span class="n">barycentric_vtx</span>
</div>
<div class="viewcode-block" id="distance"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.distance">[docs]</a><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">ptsA</span><span class="p">,</span> <span class="n">ptsB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function computing the Euclidian distance between two points A &amp; B.</span>
<span class="sd">    Can be 2D or 3D coordinates.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `ptsA` (list/numpy.array) - 2D/3D coordinates</span>
<span class="sd">     - `ptsB` (list/numpy.array) - 2D/3D coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptsA</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptsB</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;It seems that the points are not in the same space!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptsA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">ptsA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ptsB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ptsA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ptsB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptsA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">ptsA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ptsB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ptsA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ptsB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ptsA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ptsB</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="closest_from_A"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.closest_from_A">[docs]</a><span class="k">def</span> <span class="nf">closest_from_A</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">pts2search</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the closest point from A in a list of points &#39;pts2search&#39;.</span>
<span class="sd">    Return the 3D coordinates of the closest point from A.</span>
<span class="sd">    </span>
<span class="sd">    :Parameters:</span>
<span class="sd">     - `A` (list/numpy.array) - 2D/3D coordinates of the point of interest (xA, yA)/(xA, yA, zA);</span>
<span class="sd">     - `pts2search` (list) - list of 2D/3D coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dist_1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pts2search</span><span class="p">:</span>
        <span class="n">dist_2</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist_2</span> <span class="o">&lt;</span> <span class="n">dist_1</span><span class="p">:</span>
            <span class="n">pts_min_dist</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">dist_1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dist_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pts_min_dist</span>
</div>
<div class="viewcode-block" id="return_list_of_vectors"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.return_list_of_vectors">[docs]</a><span class="k">def</span> <span class="nf">return_list_of_vectors</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">by_row</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a standard list of Vector3 from an array, if sorted &#39;by_row&#39; or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">by_row</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">tensor</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">by_row</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tensor</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">by_row</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Vector3</span><span class="p">(</span><span class="n">tensor</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Vector3</span><span class="p">(</span><span class="n">tensor</span><span class="p">[:,</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="p">))]</span>

</div>
<span class="n">NPLIST</span><span class="p">,</span> <span class="n">LIST</span><span class="p">,</span> <span class="n">DICT</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
 
<div class="viewcode-block" id="AbstractSpatialImageAnalysis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis">[docs]</a><span class="k">class</span> <span class="nc">AbstractSpatialImageAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object can extract a number of 2D or 3D geometric estimator from a SpatialImage </span>
<span class="sd">    (cells volume...) and the neighborhood structure (also the shared surface area of two neighboring cells).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">NPLIST</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ..warning :: Label features in the images are an arithmetic progression of continous integers.</span>
<span class="sd">        </span>
<span class="sd">        By default, we create cache of a property only if it can be used by several functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">SpatialImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="c"># -- We use this to avoid (when possible) computation of properties on background and other cells (ex: cell in image margins)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignoredlabels</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignoredlabels</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ignoredlabels</span><span class="p">)</span>

        <span class="c"># -- Sounds a bit paranoiac but usefull !!</span>
        <span class="k">if</span> <span class="n">background</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The label you provided as background is not an integer !&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">background</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The background you provided has not been detected in the image !&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">background</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;No value defining the background, some functionalities won&#39;t work !&quot;</span><span class="p">)</span>

        <span class="c"># -- Variables for caching informations:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">voxelsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_background</span> <span class="o">=</span> <span class="n">background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernels</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_of_mass</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># voxel units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_vtk</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_reduction</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_preserve_array_shape</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># -- Variables for meta-informations:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s">&quot;Filename&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">image</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s">&quot;Filename&quot;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">return_type</span>


<div class="viewcode-block" id="AbstractSpatialImageAnalysis.is3D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.is3D">[docs]</a>    <span class="k">def</span> <span class="nf">is3D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.background"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.background">[docs]</a>    <span class="k">def</span> <span class="nf">background</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background</span>
</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.ignoredlabels"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.ignoredlabels">[docs]</a>    <span class="k">def</span> <span class="nf">ignoredlabels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span>
    </div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.add2ignoredlabels"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.add2ignoredlabels">[docs]</a>    <span class="k">def</span> <span class="nf">add2ignoredlabels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list2add</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add labels to the ignoredlabels list (set) and update the self._labels cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list2add</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">list2add</span> <span class="o">=</span> <span class="p">[</span><span class="n">list2add</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Adding labels&#39;</span><span class="p">,</span> <span class="n">list2add</span><span class="p">,</span><span class="s">&#39;to the list of labels to ignore...&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">list2add</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Updating labels list...&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__labels</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.consideronlylabels"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.consideronlylabels">[docs]</a>    <span class="k">def</span> <span class="nf">consideronlylabels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list2consider</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add labels to the ignoredlabels list (set) and update the self._labels cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list2consider</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">list2consider</span> <span class="o">=</span> <span class="p">[</span><span class="n">list2consider</span><span class="p">]</span>

        <span class="n">toignore</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">list2consider</span><span class="p">)</span>
        <span class="n">integers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">toignore</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">toignore</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Adding labels&#39;</span><span class="p">,</span> <span class="n">list2add</span><span class="p">,</span><span class="s">&#39;to the list of labels to ignore...&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">toignore</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Updating labels list...&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__labels</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.save_analysis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.save_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">save_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a &#39;SpatialImageAnalysis&#39; object, under the name &#39;filename&#39;.</span>
<span class="sd">        :Parameters:</span>
<span class="sd">         - `filename` (str) - name of the file to create WITHOUT extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># If no filename is given, we create one based on the name of the SpatialImage (if possible).</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">filename</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">!=</span> <span class="bp">None</span> <span class="p">):</span> <span class="c"># None is the default value in self.__init__</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">elif</span> <span class="n">filename</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The filename is missing, and there&#39;s no information about it in &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Saving process ABORTED.&quot;</span><span class="p">)</span>

        <span class="c"># -- We make sure the file doesn&#39;t already exist !</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The file &quot;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s">&quot; already exist. Saving process ABORTED.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;.inr.gz&quot;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span><span class="o">+</span><span class="s">&quot;_analysis.pklz&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;.inr&quot;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="s">&quot;_analysis.pklz&quot;</span>

        <span class="c"># -- We save a compresed version of the file:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&quot;File &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s">&quot; succesfully created !!&quot;</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.save_image"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.save_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the image in &#39;SpatialImageAnalysis&#39; object (self.image), under the name &#39;filename&#39;.</span>
<span class="sd">        :Parameters:</span>
<span class="sd">         - `filename` (str) - name of the file to create WITHOUT extension (automatically add &#39;.inr.gz&#39;).</span>
<span class="sd">         - `overwrite` (bool) - (Optional) if True overwrite the file if found on the disk, otherwise abort.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openalea.image.serial.basics</span> <span class="kn">import</span> <span class="n">write_inrimage</span>
        <span class="c"># If no filename is given, we create one based on the name of the SpatialImage (if possible).</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">filename</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">!=</span> <span class="bp">None</span> <span class="p">):</span> <span class="c"># None is the default value in self.__init__</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">elif</span> <span class="n">filename</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The filename is missing, and there&#39;s no information about it in &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Saving process ABORTED.&quot;</span><span class="p">)</span>

        <span class="c"># -- We make sure the file doesn&#39;t already exist !</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The file &quot;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s">&quot; already exist. Saving process ABORTED.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;.inr&quot;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">+</span><span class="s">&#39;.gz&#39;</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;.inr.gz&quot;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">+</span><span class="s">&#39;.inr.gz&#39;</span>

        <span class="c"># -- We save a compresed version of the file:</span>
        <span class="n">write_inrimage</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;File &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s">&quot; succesfully created !!&quot;</span>

</div>
    <span class="k">def</span> <span class="nf">__array2vtk_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">preserve_array_shape</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function create a vtk file of the SpatialImage (array).</span>
<span class="sd">        Each cell will be a closed mesh, which deciomation is controlled by the `reduction` factor.</span>
<span class="sd">        This code has been adapted from one written by Vincent Mirabet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
            <span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">enthought.mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
            <span class="kn">from</span> <span class="nn">enthought.tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>
        <span class="c">#~ mlab.options.offscreen = True</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">preserve_array_shape</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;The original `SpatialImage` has the following shape: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="n">s</span><span class="o">/</span><span class="mi">300</span><span class="p">])</span>
            <span class="k">print</span> <span class="s">&quot;Zoom computation... using 1 value every {} in each direction (x, y and z)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[::</span><span class="n">n</span><span class="p">,::</span><span class="n">n</span><span class="p">,::</span><span class="n">n</span><span class="p">]</span>
            <span class="k">print</span> <span class="s">&quot;The `SpatialImage` used to create the vtk object now has the following shape: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="k">print</span> <span class="s">&quot;Now need to recompute the boundingboxes...&quot;</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">img</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">labels</span><span class="p">))]</span>

        <span class="n">cell_sl</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">j</span><span class="p">:</span>
                <span class="c">#ici rajouter la correction pour agrandir la slice</span>
                <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">j</span>
                <span class="n">xd</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">][</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">xf</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="p">][</span><span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="o">==</span><span class="n">xmax</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">yd</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">start</span><span class="p">][</span><span class="n">y</span><span class="o">.</span><span class="n">start</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">yf</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">stop</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">stop</span><span class="p">][</span><span class="n">y</span><span class="o">.</span><span class="n">stop</span><span class="o">==</span><span class="n">ymax</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">zd</span><span class="o">=</span><span class="p">[</span><span class="n">z</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">z</span><span class="o">.</span><span class="n">start</span><span class="p">][</span><span class="n">z</span><span class="o">.</span><span class="n">start</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">zf</span><span class="o">=</span><span class="p">[</span><span class="n">z</span><span class="o">.</span><span class="n">stop</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">z</span><span class="o">.</span><span class="n">stop</span><span class="p">][</span><span class="n">z</span><span class="o">.</span><span class="n">stop</span><span class="o">==</span><span class="n">zmax</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cell_sl</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">xd</span><span class="p">,</span><span class="n">xf</span><span class="p">,</span><span class="n">yd</span><span class="p">,</span><span class="n">yf</span><span class="p">,</span><span class="n">zd</span><span class="p">,</span><span class="n">zf</span> <span class="c"># &#39;i+1&#39; &#39;cause the `for loop` start at &#39;0&#39; and the `nd.find_objects` start at `1`</span>

        <span class="k">print</span> <span class="s">&quot;Creating a vtk Surface of each cell...&quot;</span>
        <span class="n">cell_vtk</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nb_cell</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cell</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cell_sl</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_cell</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;{}%...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span><span class="o">+=</span><span class="mi">10</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="n">cell_sl</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span>
                <span class="n">ms</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">sl</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">sl</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">sl</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span><span class="n">sl</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">ms</span><span class="p">[</span><span class="n">ms</span><span class="o">!=</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">src</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">scalar_field</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
                <span class="n">thresh_filter</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">ImageThreshold</span><span class="p">()</span>
                <span class="n">lower_thr</span><span class="p">,</span> <span class="n">upper_thr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">cell</span>
                <span class="n">thresh_filter</span><span class="o">.</span><span class="n">threshold_between</span><span class="p">(</span><span class="n">lower_thr</span><span class="p">,</span> <span class="n">upper_thr</span><span class="p">)</span>
                <span class="n">thresh</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">user_defined</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">thresh_filter</span><span class="p">)</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">contour</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">contours</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="p">,</span> <span class="p">]</span>
                <span class="n">contour</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">j</span><span class="o">+</span><span class="n">sl</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">k</span><span class="o">+</span><span class="n">sl</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">contour</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">]</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">decimate_pro</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
                <span class="n">dec</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">target_reduction</span> <span class="o">=</span> <span class="n">reduction</span>
                <span class="n">connect_</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">PolyDataConnectivityFilter</span><span class="p">(</span><span class="n">extraction_mode</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
                <span class="n">connect</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">user_defined</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">connect_</span><span class="p">)</span>
                <span class="n">compute_normals</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">poly_data_normals</span><span class="p">(</span><span class="n">connect</span><span class="p">)</span>
                <span class="n">compute_normals</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">feature_angle</span> <span class="o">=</span> <span class="mi">60</span>
                <span class="c">#~ res=compute_normals.outputs[0]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">connect</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compute_normals</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">))</span><span class="o">*</span><span class="n">cell</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cell_ids&quot;</span>
                    <span class="n">cell_vtk</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">to_vtk</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">del</span> <span class="n">ms</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">connect</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">src</span>

        <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_vtk</span> <span class="o">=</span> <span class="n">cell_vtk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_reduction</span> <span class="o">=</span> <span class="n">reduction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_preserve_array_shape</span> <span class="o">=</span> <span class="n">preserve_array_shape</span>
        <span class="k">return</span> <span class="bp">None</span>


    <span class="k">def</span> <span class="nf">_append_cell_vtk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function used to obtain a displayable vtk</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">vtk</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span>
        <span class="c"># vtkAppend is a vtk function appending several polydata:</span>
        <span class="n">ap</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkAppendPolyData</span><span class="p">();</span> <span class="n">no_mesh</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="c"># cell_vtk is a dictionary [int]-[vtkPolyData] == [cell_id]-[cell_mesh]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ap</span><span class="o">.</span><span class="n">AddInput</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell_vtk</span><span class="p">[</span><span class="n">cell</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">no_mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">no_mesh</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">print</span> <span class="s">&quot;Warning: the following provided labels do not have any mesh: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">no_mesh</span><span class="p">)</span>

        <span class="c">#~ labels = list(set(labels)-set(no_mesh))</span>
        <span class="c">#~ # We now make sure all data within the vtkPolyData (cell_vtk) are in vtkAppendPolyData (ap)</span>
        <span class="c">#~ cell = self._cell_vtk[labels[-1]]</span>
        <span class="c">#~ for k in range(cell.GetCellData().GetNumberOfArrays()):</span>
            <span class="c">#~ name = cell.GetCellData().GetArrayName(k)</span>
            <span class="c">#~ ap.SetInputArrayToProcess(0,0,0,k,name)</span>
        
        <span class="c"># IMPORTANT: ensure vtk pipeline to be active!</span>
        <span class="n">ap</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="n">cell_vtkSep</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">()</span>
        <span class="n">cell_vtkSep</span><span class="o">.</span><span class="n">DeepCopy</span><span class="p">(</span><span class="n">ap</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">del</span> <span class="n">ap</span>

        <span class="k">return</span> <span class="n">cell_vtkSep</span>


<div class="viewcode-block" id="AbstractSpatialImageAnalysis.get_cell_vtk_surfaces"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.get_cell_vtk_surfaces">[docs]</a>    <span class="k">def</span> <span class="nf">get_cell_vtk_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">preserve_array_shape</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function used to return a dictionary [int]-[vtkPolyData] corresponding to [cell_id]-[cell_meshed_surface].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check the provided `labels`:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_handler</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c"># If no &#39;self._cell_vtk&#39; can be found or the vtk_surfaces parameters have changed, we need to recompute the vtk_surfaces:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell_vtk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">reduction</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_reduction</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">preserve_array_shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_preserve_array_shape</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__array2vtk_surfaces</span><span class="p">(</span><span class="n">reduction</span><span class="p">,</span> <span class="n">preserve_array_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_cell_vtk</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.write_vtk"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.write_vtk">[docs]</a>    <span class="k">def</span> <span class="nf">write_vtk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_vtkSep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">preserve_array_shape</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a final vtk file containing the &#39;vtk surface&#39; of each provided labels using `vtk.vtkAppendPolyData`.</span>
<span class="sd">        :Parameters:</span>
<span class="sd">        INPUT:</span>
<span class="sd">         - `cell_vtkSep` (vtk.vtkPolyData) : typically an object returned by `self.get_cell_vtk_surfaces`;</span>
<span class="sd">         - `fname` (str) : the name under wich to create the vtk file;</span>
<span class="sd">         - `labels` (int|list|str) : cell labels to be written within the vtk file;</span>
<span class="sd">         - `reduction` (float) : decimation factor used when creating the surface;</span>
<span class="sd">         - `preserve_array_shape` (bool) : if True, the whole array is used to create the cell vtk_surfaces, else a compressed version is used (of at leat a factor 2);</span>

<span class="sd">        This code has been adapted from one written by Vincent Mirabet.</span>
<span class="sd">        Visualisation using Mayavi2:</span>
<span class="sd">         1. &#39;Add a data source&#39; &gt; &#39;Load data from file&#39; &gt; select your vtk file</span>
<span class="sd">         2. Select the &#39;VTK file&#39; in the pipeline (upper left)</span>
<span class="sd">         3. &#39;Add a visualisation module&#39; &gt; select &#39;surface&#39;</span>
<span class="sd">        Or the shell command:  mayavi2 -d &lt;my_data&gt;.vtk -m Surface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">vtk</span>
        <span class="c"># Handle the case were no vtk filename is given:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fname</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)):</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;No filename found within the meta-informations, please provide one!&quot;</span><span class="p">)</span>

        <span class="c"># Check the vtk file extension:</span>
        <span class="k">if</span> <span class="n">fname</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s">&quot;.vtk&quot;</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s">&quot;.vtk&quot;</span>

        <span class="c"># Check the provided `labels`:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_handler</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c"># If no &#39;cell_vtk&#39; is provided and no cell &#39;vtk surface&#39; can be found:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cell_vtkSep</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">cell_vtkSep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_vtk_surfaces</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">preserve_array_shape</span><span class="p">)</span>

        <span class="c"># Now write a vtk file for the given `labels` using `self._append_cell_vtk`</span>
        <span class="n">w</span><span class="o">=</span><span class="n">vtk</span><span class="o">.</span><span class="n">vtkPolyDataWriter</span><span class="p">()</span>
        <span class="n">w</span><span class="o">.</span><span class="n">SetFileName</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">SetInput</span><span class="p">(</span><span class="n">cell_vtkSep</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">()</span>
        <span class="k">return</span> <span class="s">&quot;Successfully created the vtk file &#39;{}&#39;!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.read_vtk"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.read_vtk">[docs]</a>    <span class="k">def</span> <span class="nf">read_vtk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vtk_fname</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">vtk</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPolyDataReader</span><span class="p">()</span>
        <span class="n">reader</span><span class="o">.</span><span class="n">SetFileName</span><span class="p">(</span><span class="n">vtk_fname</span><span class="p">)</span>
        <span class="n">reader</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_vtk</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_vtk</span><span class="o">.</span><span class="n">DeepCopy</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">return</span> <span class="s">&quot;Successfully read the vtk file &#39;{}&#39;!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vtk_fname</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.vtk_display"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.vtk_display">[docs]</a>    <span class="k">def</span> <span class="nf">vtk_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">CM_nb_labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">CM_nb_colors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">CM_data_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">AzElDi</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">focaldist</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">&#39;jet&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">vtk</span><span class="p">;</span> <span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span><span class="p">;</span> <span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">offscreen</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;offscreen&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">offscreen</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Check the provided `labels`:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_handler</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;random&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">random_color_dict</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;volume&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

        <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">CM_data_range</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">CM_data_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">mini</span><span class="p">,</span><span class="n">maxi</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span> <span class="o">=</span> <span class="n">CM_data_range</span>
        <span class="k">if</span> <span class="n">CM_nb_colors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">CM_nb_colors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">256</span><span class="p">))</span> <span class="k">else</span> <span class="mi">256</span>
        <span class="k">if</span> <span class="n">CM_nb_labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">CM_nb_labels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">))</span> <span class="k">else</span> <span class="mi">8</span>

        <span class="n">cell_vtkSep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_vtk_surfaces</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c"># - Now project the data onto the vtk representation :</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">])</span>
        <span class="n">tvt</span><span class="o">=</span><span class="n">tvtk</span><span class="o">.</span><span class="n">to_tvtk</span><span class="p">(</span><span class="n">cell_vtkSep</span><span class="p">)</span>
        <span class="n">narray</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cel</span><span class="p">))</span> <span class="k">for</span> <span class="n">cel</span> <span class="ow">in</span> <span class="n">tvt</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="s">&quot;cell_ids&quot;</span><span class="p">)])</span>
        <span class="n">n</span><span class="o">=</span><span class="n">tvt</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">add_array</span><span class="p">(</span><span class="n">narray</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="n">tvt</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">tvt</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">tvt</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">mini</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">maxi</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">lookup_table</span><span class="o">.</span><span class="n">nan_color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">lookup_table</span><span class="o">.</span><span class="n">ramp</span><span class="o">=</span><span class="s">&#39;linear&#39;</span>
        <span class="c"># Manage lut display:</span>
        <span class="n">col_bar</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">orientation</span><span class="o">=</span><span class="s">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">nb_labels</span><span class="o">=</span><span class="n">CM_nb_labels</span><span class="p">,</span> <span class="n">nb_colors</span><span class="o">=</span><span class="n">CM_nb_colors</span><span class="p">,</span> <span class="n">label_fmt</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">col_bar</span><span class="o">.</span><span class="n">label_text_property</span><span class="o">.</span><span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
        <span class="n">col_bar</span><span class="o">.</span><span class="n">title_text_property</span><span class="o">.</span><span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
        <span class="n">col_bar</span><span class="o">.</span><span class="n">label_text_property</span><span class="o">.</span><span class="n">trait_set</span><span class="p">(</span><span class="n">vertical_justification</span><span class="o">=</span><span class="s">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="n">col_bar</span><span class="o">.</span><span class="n">label_text_property</span><span class="o">.</span><span class="n">trait_set</span><span class="p">(</span><span class="n">shadow</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">col_bar</span><span class="o">.</span><span class="n">trait_set</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="n">colorbar</span><span class="p">)</span>
        <span class="c">#~ col_bar.scalar_bar.trait_set(text_position=&#39;precede_scalar_bar&#39;)</span>
        <span class="c"># Top view:</span>
        <span class="k">if</span> <span class="n">AzElDi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">AzElDi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AzElDi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">AzElDi</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">focaldist</span><span class="p">,</span> <span class="n">reset_roll</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">roll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">roll</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;savefig&#39;</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">mlab</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">offscreen</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">clf</span><span class="p">();</span> <span class="n">mlab</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">tvt</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">col_bar</span>
</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.convert_return"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.convert_return">[docs]</a>    <span class="k">def</span> <span class="nf">convert_return</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">overide_return_type</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function convert outputs of analysis functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp_save_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overide_return_type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">overide_return_type</span>
        <span class="c"># -- In case of unique label, just return the result for this label</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tmp_save_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span>
        <span class="c"># -- return a numpy array</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">==</span> <span class="n">NPLIST</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tmp_save_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span>
        <span class="c"># -- return a standard python list</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">==</span> <span class="n">LIST</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tmp_save_type</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c"># -- return a dictionary </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tmp_save_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">values</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.labels"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.labels">[docs]</a>    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of labels used.</span>

<span class="sd">        :Examples:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>

<span class="sd">        &gt;&gt;&gt; analysis.labels()</span>
<span class="sd">        [1,2,3,4,5,6,7]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__labels</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>
</div>
    <span class="k">def</span> <span class="nf">__labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the actual list of labels.</span>
<span class="sd">        :IMPORTANT: `background` is not in the list of labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">))</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>

<div class="viewcode-block" id="AbstractSpatialImageAnalysis.nb_labels"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.nb_labels">[docs]</a>    <span class="k">def</span> <span class="nf">nb_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of labels.</span>

<span class="sd">        :Examples:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>

<span class="sd">        &gt;&gt;&gt; analysis.nb_labels()</span>
<span class="sd">        7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="bp">None</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__labels</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_labels_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following lines are often needed to ensure the correct format of labels, as well as their presence within the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span> <span class="p">)</span>
            <span class="n">not_in_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">not_in_labels</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="k">print</span> <span class="s">&quot;The following ids were not found within the image labels: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">not_in_labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">):</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;l1&#39;</span><span class="p">):</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;This is not usable as `labels`: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">labels</span>


<div class="viewcode-block" id="AbstractSpatialImageAnalysis.center_of_mass"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.center_of_mass">[docs]</a>    <span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the center of mass of the labels.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">         - `labels` (int) - single label number or a sequence of label numbers of the objects to be measured.</span>
<span class="sd">            If labels is None, all labels are used.</span>
<span class="sd">         - `real` (bool) - If True (default), center of mass is in real-world units else in voxels.</span>
<span class="sd">        </span>
<span class="sd">        :Examples:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; analysis.center_of_mass(7)</span>
<span class="sd">        [0.75, 2.75, 0.0]</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; analysis.center_of_mass([7,2])</span>
<span class="sd">        [[0.75, 2.75, 0.0], [1.3333333333333333, 0.66666666666666663, 0.0]]</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; analysis.center_of_mass()</span>
<span class="sd">        [[1.8, 2.2999999999999998, 0.0],</span>
<span class="sd">         [1.3333333333333333, 0.66666666666666663, 0.0],</span>
<span class="sd">         [1.5, 4.5, 0.0],</span>
<span class="sd">         [3.0, 3.0, 0.0],</span>
<span class="sd">         [1.0, 2.0, 0.0],</span>
<span class="sd">         [1.0, 1.0, 0.0],</span>
<span class="sd">         [0.75, 2.75, 0.0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check the provided `labels`:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_handler</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="n">center</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_of_mass</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="n">center</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_of_mass</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    <span class="n">crop_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
                    <span class="n">c_o_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">crop_im</span><span class="p">,</span> <span class="n">crop_im</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">l</span><span class="p">))</span>
                    <span class="n">c_o_m</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_o_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">slice</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">crop_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
                    <span class="n">c_o_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">crop_im</span><span class="p">,</span> <span class="n">crop_im</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">l</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_center_of_mass</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_o_m</span>
                <span class="n">center</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_o_m</span>

        <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">l</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">center</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">center</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.boundingbox"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.boundingbox">[docs]</a>    <span class="k">def</span> <span class="nf">boundingbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bounding box of a label.</span>

<span class="sd">        :Examples:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>

<span class="sd">        &gt;&gt;&gt; analysis.boundingbox(7)</span>
<span class="sd">        (slice(0, 3), slice(2, 4), slice(0, 1))</span>

<span class="sd">        &gt;&gt;&gt; analysis.boundingbox([7,2])</span>
<span class="sd">        [(slice(0, 3), slice(2, 4), slice(0, 1)), (slice(0, 3), slice(0, 2), slice(0, 1))]</span>

<span class="sd">        &gt;&gt;&gt; analysis.boundingbox()</span>
<span class="sd">        [(slice(0, 4), slice(0, 6), slice(0, 1)),</span>
<span class="sd">        (slice(0, 3), slice(0, 2), slice(0, 1)),</span>
<span class="sd">        (slice(1, 3), slice(4, 6), slice(0, 1)),</span>
<span class="sd">        (slice(3, 4), slice(3, 4), slice(0, 1)),</span>
<span class="sd">        (slice(1, 2), slice(2, 3), slice(0, 1)),</span>
<span class="sd">        (slice(1, 2), slice(1, 2), slice(0, 1)),</span>
<span class="sd">        (slice(0, 3), slice(2, 4), slice(0, 1))]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nd</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">())</span>
        
        <span class="c"># bbox of object labelled 1 to n are stored into self._bbox. To access i-th element, we have to use i-1 index</span>
        <span class="k">if</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">bboxes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">real</span> <span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">([</span><span class="n">real_indices</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span><span class="n">labels</span><span class="p">)</span>

        <span class="k">else</span> <span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">real</span><span class="p">:</span>  <span class="k">return</span> <span class="n">real_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">[</span><span class="n">labels</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">[</span><span class="n">labels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.neighbors"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real_surface</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of neighbors of a label.</span>

<span class="sd">        :WARNING:</span>
<span class="sd">            If `min_contact_surface` is given it should be in real world units.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">         - `labels` (None|int|list) - label or list of labels of which we want to return the neighbors. If none, neighbors for all labels found in self.image will be returned.</span>
<span class="sd">         - `min_contact_surface` (None|int|float) - value of the min contact surface threshold.</span>
<span class="sd">         - `real_surface` (bool) - indicate wheter the min contact surface is a real world value or a number of voxels.</span>

<span class="sd">        :Examples:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>

<span class="sd">        &gt;&gt;&gt; analysis.neighbors(7)</span>
<span class="sd">        [1, 2, 3, 4, 5]</span>

<span class="sd">        &gt;&gt;&gt; analysis.neighbors([7,2])</span>
<span class="sd">        {7: [1, 2, 3, 4, 5], 2: [1, 6, 7] }</span>

<span class="sd">        &gt;&gt;&gt; analysis.neighbors()</span>
<span class="sd">        {1: [2, 3, 4, 5, 6, 7],</span>
<span class="sd">         2: [1, 6, 7],</span>
<span class="sd">         3: [1, 7],</span>
<span class="sd">         4: [1, 7],</span>
<span class="sd">         5: [1, 6, 7],</span>
<span class="sd">         6: [1, 2, 5],</span>
<span class="sd">         7: [1, 2, 3, 4, 5] }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min_contact_surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">real_surface</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">u&quot;Neighbors will be filtered according to a min contact surface of </span><span class="si">%.2f</span><span class="s"> </span><span class="se">\u03bc</span><span class="s">m</span><span class="se">\u00B2</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">min_contact_surface</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Neighbors will be filtered according to a min contact surface of </span><span class="si">%d</span><span class="s"> voxels&quot;</span> <span class="o">%</span><span class="n">min_contact_surface</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_neighbors</span><span class="p">(</span><span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">labels</span> <span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors_with_mask</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors_from_list_with_mask</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_neighbors_with_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real_surface</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">if</span>  <span class="n">min_contact_surface</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors_filtering_by_contact_surface</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">ex_slices</span> <span class="o">=</span> <span class="n">dilation</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
            <span class="n">mask_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ex_slices</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">mask_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">contact_surface</span><span class="p">(</span><span class="n">mask_img</span><span class="p">,</span><span class="n">label</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">min_contact_surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors_filtering_by_contact_surface</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">neigh</span>


    <span class="k">def</span> <span class="nf">_neighbors_from_list_with_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real_surface</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="ow">is</span> <span class="bp">None</span> <span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>
            <span class="k">if</span>  <span class="n">min_contact_surface</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_with_surface</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">ex_slices</span> <span class="o">=</span> <span class="n">dilation</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
                <span class="n">mask_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ex_slices</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">mask_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">contact_surface</span><span class="p">(</span><span class="n">mask_img</span><span class="p">,</span><span class="n">label</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">min_contact_surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">neigh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors_filtering_by_contact_surface</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">neigh</span>

        <span class="k">return</span> <span class="n">edges</span>

    <span class="k">def</span> <span class="nf">_all_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real_surface</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span>
            <span class="k">if</span>  <span class="n">min_contact_surface</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_with_surface</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># store src, target</span>
        <span class="n">slice_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">slice_label</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="n">label</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">slices</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">slices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slice_label</span><span class="p">))</span>
            <span class="c"># label_id = label +1 because the label_id begin at 1</span>
            <span class="c"># and the enumerate begin at 0.</span>
        <span class="k">for</span> <span class="n">label_id</span><span class="p">,</span> <span class="n">slices</span> <span class="ow">in</span> <span class="n">slice_label</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c"># sometimes, the label doesn&#39;t exist ans slices is None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ex_slices</span> <span class="o">=</span> <span class="n">dilation</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
                <span class="n">mask_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ex_slices</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">mask_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">contact_surface</span><span class="p">(</span><span class="n">mask_img</span><span class="p">,</span><span class="n">label_id</span><span class="p">))</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">label_id</span><span class="p">]</span><span class="o">=</span><span class="n">neigh</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="k">if</span> <span class="n">min_contact_surface</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_with_surface</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_filter_with_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neigborhood_dictionary</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function filtering a neighborhood dictionary according to a minimal contact surface between two neigbhors.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">         - `neigborhood_dictionary` (dict) - dictionary of neighborhood to be filtered.</span>
<span class="sd">         - `min_contact_surface` (None|int|float) - value of the min contact surface threshold.</span>
<span class="sd">         - `real_surface` (bool) - indicate wheter the min contact surface is a real world value or a number of voxels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">neigborhood_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">filtered_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors_filtering_by_contact_surface</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">neigborhood_dictionary</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filtered_dict</span>

    <span class="k">def</span> <span class="nf">_neighbors_filtering_by_contact_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function used to filter the returned neighbors according to a given minimal contact surface between them!</span>

<span class="sd">        :Parameters:</span>
<span class="sd">         - `label` (int) - label of the image to threshold by the min contact surface.</span>
<span class="sd">         - `neighbors` (list) - list of neighbors of the `label` to be filtered.</span>
<span class="sd">         - `min_contact_surface` (None|int|float) - value of the min contact surface threshold.</span>
<span class="sd">         - `real_surface` (bool) - indicate wheter the min contact surface is a real world value or a number of voxels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">surfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">surfaces</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">surfaces</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">min_contact_surface</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span> <span class="n">i</span> <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">label</span> <span class="k">else</span> <span class="n">j</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">neighbors</span>

<div class="viewcode-block" id="AbstractSpatialImageAnalysis.neighbor_kernels"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.neighbor_kernels">[docs]</a>    <span class="k">def</span> <span class="nf">neighbor_kernels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is3D</span><span class="p">():</span>
                <span class="n">X1kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">X1kernel</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">X1kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">X2kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">X2kernel</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">X2kernel</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">Y1kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">Y1kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">Y1kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">Y2kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">Y2kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">Y2kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">Z1kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">Z1kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">Z1kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">Z2kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">Z2kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">Z2kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kernels</span> <span class="o">=</span> <span class="p">(</span><span class="n">X1kernel</span><span class="p">,</span><span class="n">X2kernel</span><span class="p">,</span><span class="n">Y1kernel</span><span class="p">,</span><span class="n">Y2kernel</span><span class="p">,</span><span class="n">Z1kernel</span><span class="p">,</span><span class="n">Z2kernel</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X1kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">X1kernel</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">X1kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">X2kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">X2kernel</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">X2kernel</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">Y1kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">Y1kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">Y1kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">Y2kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">Y2kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">Y2kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kernels</span> <span class="o">=</span> <span class="p">(</span><span class="n">X1kernel</span><span class="p">,</span><span class="n">X2kernel</span><span class="p">,</span><span class="n">Y1kernel</span><span class="p">,</span><span class="n">Y2kernel</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernels</span>
</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.neighbors_number"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.neighbors_number">[docs]</a>    <span class="k">def</span> <span class="nf">neighbors_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real_surface</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of neigbors of each label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">nei</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.get_voxel_face_surface"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.get_voxel_face_surface">[docs]</a>    <span class="k">def</span> <span class="nf">get_voxel_face_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.cell_wall_surface"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.cell_wall_surface">[docs]</a>    <span class="k">def</span> <span class="nf">cell_wall_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_id</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the surface of contact between a label and its neighbors.</span>
<span class="sd">        A list or a unique id can be given as neighbors.</span>

<span class="sd">        :Examples:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>

<span class="sd">        &gt;&gt;&gt; analysis.cell_wall_surface(7,2)</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; analysis.cell_wall_surface(7,[2,5])</span>
<span class="sd">        {(2, 7): 1.0, (5, 7): 2.0}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_voxel_face_surface</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dilated_bbox</span> <span class="o">=</span>  <span class="n">dilation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label_id</span><span class="p">))</span>
            <span class="n">dilated_bbox_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">dilated_bbox</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c">#~ dilated_bbox = tuple( [slice(0,self.image.shape[i]-1) for i in xrange(len(self.image.shape))] ) #if no slice can be found we use the whole image</span>
            <span class="n">dilated_bbox_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

        <span class="n">mask_img</span> <span class="o">=</span> <span class="p">(</span><span class="n">dilated_bbox_img</span> <span class="o">==</span> <span class="n">label_id</span><span class="p">)</span>

        <span class="n">xyz_kernels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_kernels</span><span class="p">()</span>

        <span class="n">unique_neighbor</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_neighbor</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbors</span><span class="p">]</span>

        <span class="n">wall</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz_kernels</span><span class="p">)):</span>
            <span class="n">dil</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask_img</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">xyz_kernels</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">frontier</span> <span class="o">=</span> <span class="n">dilated_bbox_img</span><span class="p">[</span><span class="n">dil</span><span class="o">-</span><span class="n">mask_img</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="n">nb_pix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">[</span><span class="n">frontier</span><span class="o">==</span><span class="n">n</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">real</span><span class="p">:</span>  <span class="n">surface</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nb_pix</span><span class="o">*</span><span class="n">resolution</span><span class="p">[</span><span class="n">a</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span> <span class="p">:</span> <span class="n">surface</span> <span class="o">=</span> <span class="n">nb_pix</span>
                <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">label_id</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">label_id</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
                <span class="n">wall</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="mf">0.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">surface</span>

        <span class="k">if</span> <span class="n">unique_neighbor</span><span class="p">:</span> <span class="k">return</span> <span class="n">wall</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">else</span> <span class="p">:</span> <span class="k">return</span> <span class="n">wall</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.wall_surfaces"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.wall_surfaces">[docs]</a>    <span class="k">def</span> <span class="nf">wall_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the surface of contact between all neighbor labels.</span>
<span class="sd">        If neighbors is not given, it is computed first.</span>

<span class="sd">        :Examples:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>

<span class="sd">        &gt;&gt;&gt; analysis.wall_surfaces({ 1 : [2, 3], 2 : [6] })</span>
<span class="sd">       {(1, 2): 5.0, (1, 3): 4.0, (2, 6): 2.0 }</span>

<span class="sd">        &gt;&gt;&gt; analysis.wall_surfaces()</span>
<span class="sd">        {(1, 2): 5.0, (1, 3): 4.0, (1, 4): 2.0, (1, 5): 1.0, (1, 6): 1.0, (1, 7): 2.0, (2, 6): 2.0, (2, 7): 1.0, (3, 7): 2, (4, 7): 1, (5, 6): 1.0, (5, 7): 2.0 }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="bp">None</span> <span class="p">:</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">()</span>
        <span class="n">surfaces</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label_id</span><span class="p">,</span> <span class="n">lneighbors</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="c"># To avoid computing twice the same wall surface, we select walls between i and j with j &gt; i.</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">lneighbors</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">label_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lsurfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">label_id</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="n">real</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">lsurfaces</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                    <span class="n">surfaces</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">surfaces</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="mf">0.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">lsurfaces</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">surfaces</span> 


</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.layer1"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.layer1">[docs]</a>    <span class="k">def</span> <span class="nf">layer1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_by_surface</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">minimal_external_surface</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">real_surface</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a list of labels corresponding to the external layer of cell.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integers</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span> <span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="p">:</span> <span class="c"># __layer1 contains always all the l1 cells.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">filter_by_surface</span><span class="p">:</span>
                <span class="n">vids_surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span> <span class="o">=</span> <span class="p">[</span><span class="n">vid</span> <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span> <span class="k">if</span> <span class="p">((</span><span class="n">vids_surface</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">(),</span><span class="n">vid</span><span class="p">])))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">vids_surface</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">(),</span><span class="n">vid</span><span class="p">)]</span><span class="o">&gt;</span><span class="n">minimal_external_surface</span><span class="p">))]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer1</span>

</div>
    <span class="k">def</span> <span class="nf">__first_voxel_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_background</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the first layer of voxels at the surface of the biological object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s">&quot;Extracting the first layer of voxels...&quot;</span>
        <span class="n">mask_img_1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">())</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dil_1</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask_img_1</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">struct</span><span class="p">)</span>
        
        <span class="n">layer</span> <span class="o">=</span> <span class="n">dil_1</span> <span class="o">-</span> <span class="n">mask_img_1</span>
        
        <span class="k">if</span> <span class="n">keep_background</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="n">layer</span> <span class="o">+</span> <span class="n">mask_img_1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="n">layer</span>


<div class="viewcode-block" id="AbstractSpatialImageAnalysis.first_voxel_layer"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.first_voxel_layer">[docs]</a>    <span class="k">def</span> <span class="nf">first_voxel_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_background</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function extracting the first layer of voxels detectable from the outer surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span> <span class="ow">is</span> <span class="bp">None</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__first_voxel_layer</span><span class="p">(</span><span class="n">keep_background</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.wall_voxels_per_cells_pairs"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.wall_voxels_per_cells_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">wall_voxels_per_cells_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">neighborhood</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">only_epidermis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ignore_background</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real_surface</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the coordinates of voxels defining the &#39;wall&#39; between a pair of labels.</span>
<span class="sd">        :WARNING: if dimensionality = 2, only the cells belonging to the outer layer of the object will be used.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">         - `labels` (int|list) - label or list of labels to extract walls coordinate with its neighbors.</span>
<span class="sd">         - `neighborhood` (list|dict) - list of neighbors of label if isinstance(labels,int), if not neighborhood should be a dictionary of neighbors by labels.</span>
<span class="sd">         - `only_epidermis` (bool) - indicate if we work with the whole image or just the first layer of voxels (epidermis).</span>
<span class="sd">         - `ignore_background` (bool) - indicate whether we want to return the coordinate of the voxels defining the &#39;epidermis wall&#39; (in contact with self.background()) or not.</span>
<span class="sd">         - `min_contact_surface` (None|int|float) - value of the min contact surface threshold.</span>
<span class="sd">         - `real_surface` (bool) - indicate wheter the min contact surface is a real world value or a number of voxels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">only_epidermis</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_voxel_layer</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

        <span class="n">compute_neighborhood</span><span class="o">=</span><span class="bp">False</span>
        <span class="k">if</span> <span class="n">neighborhood</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">compute_neighborhood</span><span class="o">=</span><span class="bp">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">only_epidermis</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">only_epidermis</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
                <span class="n">compute_neighborhood</span><span class="o">=</span><span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t find any labels.&quot;</span><span class="p">)</span>

        <span class="n">dict_wall_voxels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="c"># - We compute or use the neighborhood of `label`:</span>
            <span class="k">if</span> <span class="n">compute_neighborhood</span><span class="p">:</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">neighborhood</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">neighborhood</span>
            <span class="c"># - We create a list of neighbors to ignore:</span>
            <span class="k">if</span> <span class="n">ignore_background</span><span class="p">:</span>
                <span class="n">neighbors2ignore</span> <span class="o">=</span> <span class="p">[</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neighbors2ignore</span> <span class="o">=</span> <span class="p">[</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">+</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()]</span> <span class="p">]</span>
            <span class="c"># - We remove the couples of labels from wich the &quot;wall voxels&quot; are already extracted:</span>
            <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dict_wall_voxels</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">nei</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">nei</span><span class="p">))</span> <span class="p">):</span>
                    <span class="n">neighbors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">nei</span><span class="p">)</span>
            <span class="c"># - If there are neighbors left in the list, we extract the &quot;wall voxels&quot; between them and `label`:</span>
            <span class="k">if</span> <span class="n">neighbors</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="c">#~ if isinstance(neighborhood,dict):</span>
                    <span class="c">#~ dict_wall_voxels.update(walls_voxels_per_cell(image, label, self.boundingbox(label), neighborhood, neighbors2ignore, self.background()))</span>
                <span class="c">#~ else:</span>
                    <span class="c">#~ dict_wall_voxels.update(walls_voxels_per_cell(image, label, self.boundingbox(label), neighbors, neighbors2ignore, self.background()))</span>
                <span class="n">dict_wall_voxels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">walls_voxels_per_cell</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label</span><span class="p">),</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">neighbors2ignore</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">dict_wall_voxels</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.wall_orientation"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.wall_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">wall_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_wall_voxels</span><span class="p">,</span> <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plane_projection</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">dict_coord_points_ori</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute wall orientation according to fitting degree and dimensionality.</span>
<span class="sd">        :WARNING: if plane_projection, voxels will projected on a plane according to a least square regression (made here by a base projection from a SVD)</span>

<span class="sd">        :Parameters:</span>
<span class="sd">         - `dict_wall_voxels` (dict) - dictionary of voxels to be fitted by a surface (*keys = couple of neighbor labels; *values = set of coordinates)</span>
<span class="sd">         - `fitting_degree` (int) - number of &#39;curvature&#39; (local differential properties) allowed for the fitted surface.</span>
<span class="sd">         - `plane_projection` (bool) - if True, the voxels coordinates will projected on a plane according to a least square regression.</span>
<span class="sd">         - `dict_coord_points_ori` (None|dict) - dictionary of coordinate defining the origin point where to fit the surface. If None, will be computed as the geometric median of the point set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openalea.plantgl.all</span> <span class="kn">import</span> <span class="n">principal_curvatures</span>
        <span class="n">integers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="n">pc_values</span><span class="p">,</span> <span class="n">pc_normal</span><span class="p">,</span> <span class="n">pc_directions</span><span class="p">,</span> <span class="n">pc_origin</span> <span class="o">=</span> <span class="p">{},{},{},{}</span> 
        <span class="c">## For each 3D points (*keys = couple of neighbor labels) set of coordinates (defining a wall), we will fit a &quot;plane&quot;:</span>
        <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_wall_voxels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label_1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;There might be something wrong between cells </span><span class="si">%d</span><span class="s"> and </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">label_1</span>  <span class="o">%</span><span class="n">label_2</span>
                <span class="k">continue</span> <span class="c"># if None, means no points to estimate wall orientation !!</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="c"># the points set</span>
            <span class="k">if</span> <span class="n">plane_projection</span><span class="p">:</span>
                <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#there will be no curvature since the wall will be flatenned !</span>
                <span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span><span class="p">,</span> <span class="n">z_bar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">centered_point_set_3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="n">x_bar</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="n">y_bar</span><span class="p">,</span><span class="n">z</span><span class="o">-</span><span class="n">z_bar</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">centered_point_set_3D</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">proj_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">centered_point_set_3D</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">V</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]))</span>
                <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">proj_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x_bar</span><span class="p">,</span> <span class="n">proj_points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">y_bar</span><span class="p">,</span> <span class="n">proj_points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">z_bar</span>
            <span class="c">## We need to find an origin: the closest point in set set from the geometric median</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dict_coord_points_ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dict_coord_points_ori</span><span class="o">.</span><span class="n">has_key</span><span class="p">((</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)):</span>
                <span class="n">closest_voxel_coords</span> <span class="o">=</span> <span class="n">dict_coord_points_ori</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">closest_voxel_coords</span> <span class="o">=</span> <span class="n">find_wall_median_voxel</span><span class="p">(</span> <span class="p">{(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">):</span><span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]},</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
            <span class="n">id_min_dist</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">closest_voxel_coords</span><span class="p">)</span>
            <span class="c">## We can now compute the curvature values, direction, normal and origin (Monge):</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="n">principal_curvatures</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">id_min_dist</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">fitting_degree</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">pc</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pc</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pc_values</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pc_normal</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pc_directions</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pc_origin</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pc_values</span><span class="p">,</span> <span class="n">pc_normal</span><span class="p">,</span> <span class="n">pc_directions</span><span class="p">,</span> <span class="n">pc_origin</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.inertia_axis_normal_to_surface"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.inertia_axis_normal_to_surface">[docs]</a>    <span class="k">def</span> <span class="nf">inertia_axis_normal_to_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inertia_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the inertia axis defining the &quot;Z&quot; orientation of the cell.</span>
<span class="sd">        We define it to be the one correlated to the normal vector to the surface.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">         - `labels` (int) - single label number or a sequence of label numbers of the objects to be measured.</span>
<span class="sd">            If labels is None, all labels are used.</span>
<span class="sd">         - `real` (bool) - If real = True, center of mass is in real-world units else in voxels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># -- If &#39;labels&#39; is `None`, we apply the function to all L1 cells:</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">tmp_labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">diff</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">tmp_labels</span>
                <span class="k">print</span> <span class="s">&quot;Some of the provided `labels` does not belong to the L1.&quot;</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;Unused labels: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        
        <span class="c"># -- If &#39;inertia_axis&#39; is `None`, we compute them:</span>
        <span class="k">if</span> <span class="n">inertia_axis</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">inertia_axis</span><span class="p">,</span> <span class="n">inertia_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inertia_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="n">real</span><span class="p">)</span>

        <span class="n">surface_normal_axis</span><span class="o">=</span><span class="p">[];</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n_cell</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n_cell</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_normal</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_principal_curvatures</span><span class="p">(</span> <span class="n">cell</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">fitting_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">monge_degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_normal</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span>
            <span class="n">max_corr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n_corr</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">for</span> <span class="n">n_vect</span><span class="p">,</span><span class="n">inertia_vect</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inertia_axis</span><span class="p">[</span><span class="n">cell</span><span class="p">]):</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">vector_correlation</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">inertia_vect</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span><span class="o">&gt;</span><span class="n">max_corr</span><span class="p">:</span>
                    <span class="n">max_corr</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">corr</span><span class="p">))</span>
                    <span class="n">n_corr</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">n_vect</span><span class="p">)</span>
            
            <span class="n">surface_normal_axis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_corr</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">surface_normal_axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.remove_cells"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.remove_cells">[docs]</a>    <span class="k">def</span> <span class="nf">remove_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">erase_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use remove_cell to iterate over a list of cell to remove if there is more cells to keep than to remove.</span>
<span class="sd">        If there is more cells to remove than to keep, we fill a &quot;blank&quot; image with those to keep.</span>
<span class="sd">        :!!!!WARNING!!!!:</span>
<span class="sd">        This function modify the SpatialImage on self.image</span>
<span class="sd">        :!!!!WARNING!!!!:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">vids</span><span class="o">=</span> <span class="p">[</span><span class="n">vids</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()</span> <span class="ow">in</span> <span class="n">vids</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">vids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">())</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span>

        <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;Removing&quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s">&quot;cells.&quot;</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">vid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vids</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)])</span> <span class="o">==</span> <span class="n">vid</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="nb">tuple</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">))]</span><span class="o">=</span><span class="n">erase_value</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;No boundingbox found for cell id #{}, skipping...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span><span class="p">)</span>
        <span class="n">ignoredlabels</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">erase_value</span><span class="p">])</span>
        <span class="n">return_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span><span class="p">,</span> <span class="n">return_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Done !!&#39;</span>

</div>
<div class="viewcode-block" id="AbstractSpatialImageAnalysis.remove_margins_cells"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.AbstractSpatialImageAnalysis.remove_margins_cells">[docs]</a>    <span class="k">def</span> <span class="nf">remove_margins_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">erase_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :!!!!WARNING!!!!:</span>
<span class="sd">        This function modify the SpatialImage on self.image</span>
<span class="sd">        :!!!!WARNING!!!!:</span>
<span class="sd">        Function removing cells at the margins, because most probably cut during stack aquisition.</span>
<span class="sd">        </span>
<span class="sd">        :INPUTS:</span>
<span class="sd">            .save: text (if present) indicating under which name to save the Spatial Image containing the cells of the first layer;</span>
<span class="sd">            .display: boolean indicating if we should display the previously computed image;</span>
<span class="sd">        </span>
<span class="sd">        :OUPUT:</span>
<span class="sd">            Spatial Image without the cell&#39;s at the margins.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;Removing cells at the margins of the stack...&quot;</span>

        <span class="c"># -- We start by making sure that there is not only one cell in the image (appart from 0 and 1)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()))</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span> <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span> <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Only one cell left in your image, we won&#39;t take it out !&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>

        <span class="c"># -- Then we recover the list of border cells and delete the from the image:</span>
        <span class="n">cells_in_image_margins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells_in_image_margins</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">erase_value</span> <span class="ow">in</span> <span class="n">cells_in_image_margins</span><span class="p">:</span> <span class="n">cells_in_image_margins</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">erase_value</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_in_image_margins</span><span class="p">);</span> <span class="n">percent</span><span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells_in_image_margins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span> <span class="o">==</span> <span class="n">c</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="nb">tuple</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">))]</span><span class="o">=</span><span class="n">erase_value</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;No boundingbox found for cell id #{}, skipping...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
                <span class="k">continue</span>
        
        <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ignoredlabels</span><span class="p">)</span>
        <span class="n">ignoredlabels</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">erase_value</span><span class="p">])</span>
        <span class="n">return_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span><span class="p">,</span> <span class="n">return_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_erase_value</span> <span class="o">=</span> <span class="n">erase_value</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Done !!&#39;</span>

</div></div>
<div class="viewcode-block" id="SpatialImageAnalysis2D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis2D">[docs]</a><span class="k">class</span> <span class="nc">SpatialImageAnalysis2D</span> <span class="p">(</span><span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class dedicated to 2D objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">NPLIST</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">AbstractSpatialImageAnalysis</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span><span class="p">,</span> <span class="n">return_type</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>


<div class="viewcode-block" id="SpatialImageAnalysis2D.cells_in_image_margins"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis2D.cells_in_image_margins">[docs]</a>    <span class="k">def</span> <span class="nf">cells_in_image_margins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of cells in contact with the margins of the stack (SpatialImage).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">margins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">margins</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_background</span><span class="p">]))</span>

</div>
<div class="viewcode-block" id="SpatialImageAnalysis2D.inertia_axis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis2D.inertia_axis">[docs]</a>    <span class="k">def</span> <span class="nf">inertia_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">center_of_mass</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inertia axis of cells, also called the shape main axis.</span>
<span class="sd">        Returns 2 (2D-oriented) vectors and 2 (length) values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>

        <span class="c"># results</span>
        <span class="n">inertia_eig_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inertia_eig_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">i</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
            <span class="c"># project center into the slices sub_image coordinate</span>
            <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
                    <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">slice</span><span class="o">.</span><span class="n">start</span>
                <span class="n">label_image</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;No boundingbox found for label {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">label_image</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>

            <span class="c"># compute the indices of voxel with adequate label</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">label_image</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c"># obviously no reasons to go further !</span>
            <span class="c"># difference with the center</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>

            <span class="c"># compute 1/N*P.P^T</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">coord</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c"># Find the eigen values and vectors.</span>
            <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
            <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">eig_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">)</span> <span class="p">)</span>

            <span class="n">inertia_eig_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">)</span>
            <span class="n">inertia_eig_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eig_val</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">inertia_eig_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">by_row</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">inertia_eig_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">inertia_eig_vec</span><span class="p">,</span><span class="n">by_row</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">labels</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">inertia_eig_val</span><span class="p">,</span><span class="n">labels</span><span class="p">)</span>


</div></div>
<div class="viewcode-block" id="SpatialImageAnalysis3DS"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3DS">[docs]</a><span class="k">class</span> <span class="nc">SpatialImageAnalysis3DS</span> <span class="p">(</span><span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class dedicated to surfacic 3D objects. </span>
<span class="sd">    Only one layer of voxel is extracted (representing the external envelope of the biological object to analyse).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">NPLIST</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">AbstractSpatialImageAnalysis</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span><span class="p">,</span> <span class="n">return_type</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="SpatialImageAnalysis3D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D">[docs]</a><span class="k">class</span> <span class="nc">SpatialImageAnalysis3D</span><span class="p">(</span><span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class dedicated to 3D objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">NPLIST</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">AbstractSpatialImageAnalysis</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span><span class="p">,</span> <span class="n">return_type</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_normal</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_directions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_origin</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curvatures_tensor</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_wall_geometric_median</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epidermis_wall_median_voxel</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="SpatialImageAnalysis3D.is3D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.is3D">[docs]</a>    <span class="k">def</span> <span class="nf">is3D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
    </div>
<div class="viewcode-block" id="SpatialImageAnalysis3D.volume"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.volume">[docs]</a>    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume of the labels.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">         - `labels` (int) - single label number or a sequence of</span>
<span class="sd">            label numbers of the objects to be measured.</span>
<span class="sd">            If labels is None, all labels are used.</span>

<span class="sd">         - `real` (bool) - If real = True, volume is in real-world units else in voxels.</span>

<span class="sd">        :Examples:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                          [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                          [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                          [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">        &gt;&gt;&gt; from openalea.image.algo.analysis import SpatialImageAnalysis</span>
<span class="sd">        &gt;&gt;&gt; analysis = SpatialImageAnalysis(a)</span>

<span class="sd">        &gt;&gt;&gt; analysis.volume(7)</span>
<span class="sd">        4.0</span>

<span class="sd">        &gt;&gt;&gt; analysis.volume([7,2])</span>
<span class="sd">        [4.0, 3.0]</span>

<span class="sd">        &gt;&gt;&gt; analysis.volume()</span>
<span class="sd">        [10.0, 3.0, 4.0, 1.0, 1.0, 1.0, 4.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">labels</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>

        <span class="n">volume</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">real</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">volume</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">volume</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">volume</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">volume</span>

</div>
<div class="viewcode-block" id="SpatialImageAnalysis3D.inertia_axis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.inertia_axis">[docs]</a>    <span class="k">def</span> <span class="nf">inertia_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inertia axis of cells, also called the shape main axis.</span>
<span class="sd">        Return 3 (3D-oriented) vectors by rows and 3 (length) values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check the provided `labels`:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_handler</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="c"># results</span>
        <span class="n">inertia_eig_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inertia_eig_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">);</span> <span class="n">percent</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">i</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
            <span class="c"># project center into the slices sub_image coordinate</span>
            <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
                    <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">slice</span><span class="o">.</span><span class="n">start</span>
                <span class="n">label_image</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;No boundingbox found for label {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">label_image</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>

            <span class="c"># compute the indices of voxel with adequate label</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">label_image</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c"># obviously no reasons to go further !</span>
            <span class="c"># difference with the center</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>

            <span class="c"># compute 1/N*P.P^T</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">coord</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c"># Find the eigen values and vectors.</span>
            <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
            <span class="n">decreasing_index</span> <span class="o">=</span> <span class="n">eig_val</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">eig_val</span><span class="p">[</span><span class="n">decreasing_index</span><span class="p">],</span> <span class="n">eig_vec</span><span class="p">[:,</span><span class="n">decreasing_index</span><span class="p">]</span> <span class="c"># np.linalg.eig return eigenvectors by column !!</span>
            <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c"># ... our standard is by rows !</span>

            <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">eig_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">)</span> <span class="p">)</span>

            <span class="n">inertia_eig_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">)</span>
            <span class="n">inertia_eig_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eig_val</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">inertia_eig_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">inertia_eig_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">inertia_eig_vec</span><span class="p">),</span><span class="n">labels</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">inertia_eig_val</span><span class="p">,</span><span class="n">labels</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SpatialImageAnalysis3D.reduced_inertia_axis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.reduced_inertia_axis">[docs]</a>    <span class="k">def</span> <span class="nf">reduced_inertia_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the REDUCED (centered coordinates standardized) inertia axis of cells, also called the shape main axis.</span>
<span class="sd">        Return 3 (3D-oriented) vectors by rows and 3 (length) values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check the provided `labels`:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_handler</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="c"># results</span>
        <span class="n">inertia_eig_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inertia_eig_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">);</span> <span class="n">percent</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">i</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
            <span class="c"># project center into the slices sub_image coordinate</span>
            <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
                    <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">slice</span><span class="o">.</span><span class="n">start</span>
                <span class="n">label_image</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;No boundingbox found for label {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">label_image</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>

            <span class="c"># compute the indices of voxel with adequate label</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">label_image</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c"># obviously no reasons to go further !</span>
            <span class="c"># difference with the center</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">y</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="n">z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">z</span><span class="p">)])</span>

            <span class="c"># compute 1/N*P.P^T</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">coord</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c"># Find the eigen values and vectors.</span>
            <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
            <span class="n">decreasing_index</span> <span class="o">=</span> <span class="n">eig_val</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">eig_val</span><span class="p">[</span><span class="n">decreasing_index</span><span class="p">],</span> <span class="n">eig_vec</span><span class="p">[:,</span><span class="n">decreasing_index</span><span class="p">]</span> <span class="c"># np.linalg.eig return eigenvectors by column !!</span>
            <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c"># ... our standard is by rows !</span>

            <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">eig_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">)</span> <span class="p">)</span>

            <span class="n">inertia_eig_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">)</span>
            <span class="n">inertia_eig_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eig_val</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">inertia_eig_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">by_row</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">inertia_eig_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">inertia_eig_vec</span><span class="p">,</span><span class="n">by_row</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">labels</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">inertia_eig_val</span><span class="p">,</span><span class="n">labels</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SpatialImageAnalysis3D.cells_in_image_margins"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.cells_in_image_margins">[docs]</a>    <span class="k">def</span> <span class="nf">cells_in_image_margins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">voxel_distance_from_margin</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of cells in contact with the margins of the stack (SpatialImage).</span>
<span class="sd">        All ids within a defined (5 by default) voxel distance form the margins will be used to define cells as &#39;in image margins&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vx_dist</span><span class="o">=</span><span class="n">voxel_distance_from_margin</span>
        <span class="n">margins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:</span><span class="n">vx_dist</span><span class="p">,:,:]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="o">-</span><span class="n">vx_dist</span><span class="p">:,:,:]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,:</span><span class="n">vx_dist</span><span class="p">,:]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span><span class="o">-</span><span class="n">vx_dist</span><span class="p">:,:]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,:,:</span><span class="n">vx_dist</span><span class="p">]))</span>
        <span class="n">margins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,:,</span><span class="o">-</span><span class="n">vx_dist</span><span class="p">:]))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">margins</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_background</span><span class="p">]))</span>
</div>
<div class="viewcode-block" id="SpatialImageAnalysis3D.region_boundingbox"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.region_boundingbox">[docs]</a>    <span class="k">def</span> <span class="nf">region_boundingbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function return a boundingbox of a region including all cells (provided by `labels`).</span>

<span class="sd">        :Parameters:</span>
<span class="sd">         - `labels` (list): list of cells ids;</span>
<span class="sd">        :Returns:</span>
<span class="sd">         - [x_start,y_start,z_start,x_stop,y_stop,z_stop]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        
        <span class="n">dict_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c">#-- We start by making sure that all cells have an entry (key) in `dict_slices`:</span>
        <span class="n">not_found</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dict_slices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">not_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_found</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;You have asked for unknown cells labels: &#39;</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">not_found</span><span class="p">]))</span>

        <span class="c">#-- We now define a slice for the region including all cells:</span>
        <span class="n">x_start</span><span class="p">,</span><span class="n">y_start</span><span class="p">,</span><span class="n">z_start</span><span class="p">,</span><span class="n">x_stop</span><span class="p">,</span><span class="n">y_stop</span><span class="p">,</span><span class="n">z_stop</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">dict_slices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">x_start</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">x_start</span><span class="p">)</span>
            <span class="n">y_start</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">y_start</span><span class="p">)</span>
            <span class="n">z_start</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">z_start</span><span class="p">)</span>
            <span class="n">x_stop</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span><span class="n">x_stop</span><span class="p">)</span>
            <span class="n">y_stop</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span><span class="n">y_stop</span><span class="p">)</span>
            <span class="n">z_stop</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span><span class="n">z_stop</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">x_start</span><span class="p">,</span><span class="n">y_start</span><span class="p">,</span><span class="n">z_start</span><span class="p">,</span><span class="n">x_stop</span><span class="p">,</span><span class="n">y_stop</span><span class="p">,</span><span class="n">z_stop</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__principal_curvature_parameters_CGAL</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapped_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vids</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">monge_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Decorator wrapping function `compute_principal_curvatures` allowing use of various input for `vids` and preparing the necessary variables for the wrapped function.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">from</span> <span class="nn">openalea.plantgl.algo</span> <span class="kn">import</span> <span class="n">k_closest_points_from_ann</span>
            <span class="c"># -- If &#39;vids&#39; is an integer... </span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">vids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()):</span> <span class="c"># - ...but not in the L1 list, there is nothing to do!</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Cell &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">vids</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; is not in the L1. We won&#39;t compute its curvature.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># - ... and in the L1 list, we make it iterable.</span>
                    <span class="n">vids</span><span class="o">=</span><span class="p">[</span><span class="n">vids</span><span class="p">]</span>

            <span class="c"># -- If &#39;vids&#39; is a list, we make sure to keep only its &#39;vid&#39; present in the L1 list!</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">vids</span><span class="p">)</span> <span class="c"># Ensure to scan all the elements of &#39;vids&#39;</span>
                <span class="n">no_curvature</span> <span class="o">=</span> <span class="p">[</span><span class="n">vid</span> <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">vid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()]</span>
                <span class="k">if</span> <span class="n">no_curvature</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Cells {} are not in the L1. We won&#39;t compute their curvature.&quot;</span><span class="p">)</span>
                    <span class="n">vids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vids</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">no_curvature</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># if there is no element left in the &#39;vids&#39; list, there is nothing to do!</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;None of the cells you provided belong to the L1.&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="mi">0</span>

            <span class="c"># -- If &#39;vids&#39; is `None`, we apply the function to all L1 cells:</span>
            <span class="k">if</span> <span class="n">vids</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">vids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()</span>

            <span class="c"># -- Now we need the SpatialImage of the first layer of voxels without the background.</span>
            <span class="c"># - If the first layer of voxels has been extracted already, we make sure that we have exluded the background.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_voxel_layer</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()]</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">first_voxel_layer</span><span class="p">(</span><span class="n">keep_background</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

            <span class="c"># -- We make sure the radius hasn&#39;t been changed and if not defined, we save the value for further evaluation and information.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">used_radius_for_curvature</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">used_radius_for_curvature</span> <span class="o">=</span> <span class="n">radius</span>
                <span class="n">recalculate_all</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_radius_for_curvature</span> <span class="o">==</span> <span class="n">radius</span><span class="p">:</span>
                    <span class="n">recalculate_all</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">used_radius_for_curvature</span> <span class="o">=</span> <span class="n">radius</span>
                    <span class="n">recalculate_all</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c"># -- We create voxels adjacencies</span>
            <span class="n">curvature</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_voxel_layer</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
            <span class="n">adjacencies</span> <span class="o">=</span> <span class="n">k_closest_points_from_ann</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

            <span class="c"># -- Now we can compute the principal curvatures informations</span>
            <span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">geometric_median</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;Computing curvature :&#39;</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">vid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vids</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">recalculate_all</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">vid</span><span class="p">))</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">5</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
                    <span class="n">func</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">adjacencies</span><span class="p">,</span> <span class="n">fitting_degree</span><span class="p">,</span> <span class="n">monge_degree</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapped_function</span>


    <span class="nd">@__principal_curvature_parameters_CGAL</span>
<div class="viewcode-block" id="SpatialImageAnalysis3D.compute_principal_curvatures"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.compute_principal_curvatures">[docs]</a>    <span class="k">def</span> <span class="nf">compute_principal_curvatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">adjacencies</span><span class="p">,</span> <span class="n">fitting_degree</span><span class="p">,</span> <span class="n">monge_degree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function computing principal curvature using a CGAL c++ wrapped function: &#39;principal_curvatures&#39;.</span>
<span class="sd">        It&#39;s only doable for cells of the first layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openalea.plantgl.algo</span> <span class="kn">import</span> <span class="n">r_neighborhood</span><span class="p">,</span> <span class="n">principal_curvatures</span>
        <span class="c"># - Try to use the position of the closest voxel to the wall geometric median</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epidermis_wall_median_voxel</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">vid</span><span class="p">):</span>
            <span class="n">closest_voxel_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epidermis_wall_median_voxel</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># - Recover `vid` position in the image:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_voxel_layer</span><span class="p">()[</span><span class="n">bbox</span><span class="p">]</span> <span class="o">==</span> <span class="n">vid</span><span class="p">)</span>
            <span class="n">x_vid</span><span class="p">,</span> <span class="n">y_vid</span><span class="p">,</span> <span class="n">z_vid</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">slice</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bbox</span><span class="p">)]</span>
            <span class="c"># find the median voxel (more precisely, the closest voxel to the median)</span>
            <span class="n">closest_voxel_coords</span> <span class="o">=</span> <span class="n">find_wall_median_voxel</span><span class="p">(</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="n">vid</span><span class="p">):</span> <span class="p">[</span><span class="n">x_vid</span><span class="p">,</span> <span class="n">y_vid</span><span class="p">,</span> <span class="n">z_vid</span><span class="p">]},</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epidermis_wall_median_voxel</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="n">closest_voxel_coords</span>

        <span class="n">id_min_dist</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">closest_voxel_coords</span><span class="p">)</span>
        <span class="n">neigborids</span> <span class="o">=</span> <span class="n">r_neighborhood</span><span class="p">(</span><span class="n">id_min_dist</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">adjacencies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_radius_for_curvature</span><span class="p">)</span>
        <span class="c"># - Principal curvature computation:</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">principal_curvatures</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">id_min_dist</span><span class="p">,</span> <span class="n">neigborids</span><span class="p">,</span> <span class="n">fitting_degree</span><span class="p">,</span> <span class="n">monge_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">pc</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_directions</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_list_of_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pc</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pc</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]]),</span><span class="n">by_row</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_normal</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_directions</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures_origin</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#~ k1 = pc[1][1]; k2 = pc[2][1]</span>
        <span class="c">#~ R = np.array( [pc[1][0], pc[2][0], pc[0]] ).T</span>
        <span class="c">#~ D = [ [k1,0,0], [0,k2,0], [0,0,0] ]</span>
        <span class="c">#~ self.curvatures_tensor[vid] = np.dot(np.dot(R,D),R.T)</span>

</div>
    <span class="k">def</span> <span class="nf">__curvature_parameters_CGAL</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapped_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vids</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c"># -- If &#39;vids&#39; is `None`, we apply the function to all L1 cells:</span>
            <span class="k">if</span> <span class="n">vids</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">vids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()</span>

            <span class="c"># -- If &#39;vids&#39; is an integer... </span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">vids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()):</span> <span class="c"># - ...but not in the L1 list, there is nothing to do!</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Cell&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">vids</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;is not in the L1. We won&#39;t compute it&#39;s curvature.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># - ... and in the L1 list, we make it iterable.</span>
                    <span class="n">vids</span><span class="o">=</span><span class="p">[</span><span class="n">vids</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;Principal curvature not pre-computed... computing it !&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_principal_curvatures</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>

            <span class="n">curvature</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">);</span> <span class="n">percent</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">vid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vids</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">vid</span><span class="p">):</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_principal_curvatures</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># &#39;compute_principal_curvatures&#39; return a 0 when one of the vids is not in the L1.</span>
                    <span class="n">curvature</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vid</span> <span class="p">)</span>

            <span class="k">return</span> <span class="n">curvature</span>
        <span class="k">return</span> <span class="n">wrapped_function</span>


    <span class="nd">@__curvature_parameters_CGAL</span>
<div class="viewcode-block" id="SpatialImageAnalysis3D.gaussian_curvature_CGAL"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.gaussian_curvature_CGAL">[docs]</a>    <span class="k">def</span> <span class="nf">gaussian_curvature_CGAL</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vid</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gaussian curvature is the product of principal curvatures &#39;k1*k2&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</div>
    <span class="nd">@__curvature_parameters_CGAL</span>
<div class="viewcode-block" id="SpatialImageAnalysis3D.mean_curvature_CGAL"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.mean_curvature_CGAL">[docs]</a>    <span class="k">def</span> <span class="nf">mean_curvature_CGAL</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vid</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean curvature is the product of principal curvatures &#39;1/2*(k1+k2)&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</div>
    <span class="nd">@__curvature_parameters_CGAL</span>
<div class="viewcode-block" id="SpatialImageAnalysis3D.curvature_ratio_CGAL"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.curvature_ratio_CGAL">[docs]</a>    <span class="k">def</span> <span class="nf">curvature_ratio_CGAL</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vid</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Curvature ratio is the ratio of principal curvatures &#39;k1/k2&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</div>
    <span class="nd">@__curvature_parameters_CGAL</span>
<div class="viewcode-block" id="SpatialImageAnalysis3D.curvature_anisotropy_CGAL"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.curvature_anisotropy_CGAL">[docs]</a>    <span class="k">def</span> <span class="nf">curvature_anisotropy_CGAL</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vid</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Curvature Anisotropy is defined as &#39;(k1-k2)/(k1+k2)&#39;.</span>
<span class="sd">        Where k1 is the max value of principal curvature and k2 the min value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">[</span><span class="n">vid</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="SpatialImageAnalysis3D.epidermis_shape_anisotropy"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.epidermis_shape_anisotropy">[docs]</a>    <span class="k">def</span> <span class="nf">epidermis_shape_anisotropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vids</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute anisotropy of epidermis cell from inertia axis length.</span>
<span class="sd">        Based on the first layer of voxels only!!</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">         - vids (list): list of ids.</span>
<span class="sd">         - real (bool): if True, return the eigenvalues in real world units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">first_voxel_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_voxel_layer</span><span class="p">(</span><span class="n">keep_background</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vids</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">vids</span> <span class="o">=</span> <span class="p">[</span><span class="n">vids</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">vids</span><span class="p">:</span>
            <span class="n">vids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">()</span> <span class="ow">in</span> <span class="n">vids</span><span class="p">:</span>
            <span class="n">vids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">())</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">)</span>

        <span class="n">anisotropy</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">);</span> <span class="n">percent</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vids</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">first_voxel_layer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">label</span><span class="p">)]</span> <span class="o">==</span> <span class="n">label</span><span class="p">))</span>
            <span class="c"># difference with the center of mass</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">mean</span>
            <span class="c"># compute P^T.P</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">coord</span><span class="p">)</span>
            <span class="c"># Find the eigen values and vectors.</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="c"># sorted eigenvalues</span>
            <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">eig_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">anisotropy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">eig_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">eig_val</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">eig_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">eig_val</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_return</span><span class="p">(</span><span class="n">anisotropy</span><span class="p">,</span> <span class="n">vids</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SpatialImageAnalysis3D.moment_invariants"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis3D.moment_invariants">[docs]</a>    <span class="k">def</span> <span class="nf">moment_invariants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vids</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computation of 3D invariant moment (invariant to translation, rotation and scale).</span>
<span class="sd">        </span>
<span class="sd">        2nd order moments are calculated from:</span>
<span class="sd">         - Sadjadi, F. A. &amp; Hall, E. L. Three-Dimensional Moment Invariants. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1980, PAMI-2, 127-136.</span>
<span class="sd">        </span>
<span class="sd">        3rd and 4th order moments are calculated from:</span>
<span class="sd">         - Xu, D. &amp; Li, H. Geometric moment invariants. Pattern Recognition, 2008, 41, 240-249 </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># -- If &#39;vids&#39; is an integer... </span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">vids</span><span class="o">=</span><span class="p">[</span><span class="n">vids</span><span class="p">]</span>

        <span class="c"># -- If &#39;vids&#39; is `None`, we apply the function to all L1 cells:</span>
        <span class="k">if</span> <span class="n">vids</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>

        <span class="n">central_moments</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="n">I3</span><span class="p">,</span> <span class="n">I4</span><span class="p">,</span> <span class="n">I5</span><span class="p">,</span> <span class="n">I6</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="n">usefull_combinations</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> \
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> \
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> \
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> \
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">]</span>

        <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">);</span> <span class="n">percent</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">vid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vids</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)])</span> <span class="o">==</span> <span class="n">vid</span> <span class="p">)</span>
            <span class="n">x_mean</span><span class="p">,</span><span class="n">y_mean</span><span class="p">,</span><span class="n">z_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">x_res</span><span class="p">,</span> <span class="n">y_res</span><span class="p">,</span> <span class="n">z_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voxelsize</span>

            <span class="n">x_bar</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="n">x_mean</span>
            <span class="n">y_bar</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="n">y_mean</span>
            <span class="n">z_bar</span> <span class="o">=</span> <span class="n">z</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">vid</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="o">-</span><span class="n">z_mean</span>

            <span class="c">#~ for l in xrange(5):</span>
                <span class="c">#~ for m in xrange(5):</span>
                    <span class="c">#~ for n in xrange(5):</span>
                        <span class="c">#~ central_moments[l,m,n] = sum( (x_bar*x_res)**l * (y_bar*y_res)**m * (z_bar*z_res)**n )</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">usefull_combinations</span><span class="p">:</span>
                <span class="n">central_moments</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">x_bar</span><span class="o">*</span><span class="n">x_res</span><span class="p">)</span><span class="o">**</span><span class="n">l</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_bar</span><span class="o">*</span><span class="n">y_res</span><span class="p">)</span><span class="o">**</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">z_bar</span><span class="o">*</span><span class="n">z_res</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="p">)</span>

            <span class="n">I1</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="mi">7</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> \
             <span class="p">(</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>

            <span class="n">I2</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="mi">14</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> \
             <span class="p">(</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> \
             <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> \
             <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> \
             <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
             <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
             <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>

            <span class="n">I3</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="mi">14</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> \
             <span class="p">(</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> \
             <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> \
             <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> \
             <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>

            <span class="n">I4</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span> <span class="p">)</span> <span class="o">*</span> \
             <span class="p">(</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> \
             <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>

            <span class="n">I5</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span> <span class="p">)</span> <span class="o">*</span> \
             <span class="p">(</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> \
             <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

            <span class="n">I6</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span> <span class="p">)</span> <span class="o">*</span> \
             <span class="p">(</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> \
             <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> \
             <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> \
             <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">central_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">central_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="n">I3</span><span class="p">,</span> <span class="n">I4</span><span class="p">,</span> <span class="n">I5</span><span class="p">,</span> <span class="n">I6</span>


</div></div>
<div class="viewcode-block" id="load_analysis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.load_analysis">[docs]</a><span class="k">def</span> <span class="nf">load_analysis</span><span class="p">(</span> <span class="n">SpatialImageAnalysis</span><span class="p">,</span> <span class="n">filename</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a SpatialImageAnalysis from the file `filename`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">SpatialImageAnalysis</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;File &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;.pklz succesfully loaded !!&quot;</span>

</div>
<div class="viewcode-block" id="outliers_exclusion"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.outliers_exclusion">[docs]</a><span class="k">def</span> <span class="nf">outliers_exclusion</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">std_multiplier</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">display_data_plot</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list or a dict (same type as `data`) cleaned out of outliers.</span>
<span class="sd">    Outliers are detected according to a distance from standard deviation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">std</span><span class="p">,</span><span class="n">mean</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">borne</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">std_multiplier</span><span class="o">*</span><span class="n">std</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&gt;</span><span class="n">borne</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&lt;-</span><span class="n">borne</span><span class="p">):</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">borne</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="n">std_multiplier</span><span class="o">*</span><span class="n">std</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&gt;</span><span class="n">borne</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&lt;-</span><span class="n">borne</span><span class="p">):</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">display_data_plot</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">data</span> <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">tmp</span> <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">tmp</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tmp</span>

</div>
<div class="viewcode-block" id="vector_correlation"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.vector_correlation">[docs]</a><span class="k">def</span> <span class="nf">vector_correlation</span><span class="p">(</span><span class="n">vect1</span><span class="p">,</span><span class="n">vect2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute correlation between two vector, which is the the cosine of the angle between two vectors in Euclidean space of any number of dimensions.</span>
<span class="sd">    The dot product is directly related to the cosine of the angle between two vectors if they are normed !!!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># -- We make sure that we have normed vectors.</span>
    <span class="kn">from</span> <span class="nn">openalea.plantgl.math</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">Vector3</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="n">vect1</span><span class="p">)))</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">):</span>
        <span class="n">vect1</span> <span class="o">=</span> <span class="n">vect1</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="n">vect1</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="n">vect2</span><span class="p">)))</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">):</span>
        <span class="n">vect2</span> <span class="o">=</span> <span class="n">vect2</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="n">vect2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vect1</span><span class="p">,</span><span class="n">vect2</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="find_wall_median_voxel"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.find_wall_median_voxel">[docs]</a><span class="k">def</span> <span class="nf">find_wall_median_voxel</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">,</span> <span class="n">labels2exclude</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">openalea.plantgl.algo</span> <span class="kn">import</span> <span class="n">approx_pointset_median</span><span class="p">,</span> <span class="n">pointset_median</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels2exclude</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">labels2exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels2exclude</span><span class="p">]</span>

    <span class="n">wall_median</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
        <span class="k">if</span> <span class="n">label_1</span> <span class="ow">in</span> <span class="n">labels2exclude</span> <span class="ow">or</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">labels2exclude</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector3</span><span class="p">(</span><span class="nb">list</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xyz</span><span class="p">]</span>
        <span class="c"># compute geometric median:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">median_vox_id</span> <span class="o">=</span> <span class="n">pointset_median</span><span class="p">(</span> <span class="n">xyz</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">median_vox_id</span> <span class="o">=</span> <span class="n">approx_pointset_median</span><span class="p">(</span> <span class="n">xyz</span> <span class="p">)</span>
        <span class="n">wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">median_vox_id</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wall_median</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wall_median</span>

</div>
<div class="viewcode-block" id="geometric_median"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.geometric_median">[docs]</a><span class="k">def</span> <span class="nf">geometric_median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">numIter</span> <span class="o">=</span> <span class="mi">200</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the geometric median of a point sample.</span>
<span class="sd">    The geometric median coordinates will be expressed in the Spatial Image reference system (not in real world metrics).</span>
<span class="sd">    We use the Weiszfeld&#39;s algorithm (http://en.wikipedia.org/wiki/Geometric_median)</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `X` (list|np.array) - voxels coordinate (3xN matrix)</span>
<span class="sd">     - `numIter` (int) - limit the length of the search for global optimum</span>

<span class="sd">    :Return:</span>
<span class="sd">     - np.array((x,y,z)): geometric median of the coordinates;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># -- Initialising &#39;median&#39; to the centroid</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># -- If the init point is in the set of points, we shift it:</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
        <span class="n">y</span><span class="o">+=</span><span class="mf">0.1</span>

    <span class="n">convergence</span><span class="o">=</span><span class="bp">False</span> <span class="c"># boolean testing the convergence toward a global optimum</span>
    <span class="n">dist</span><span class="o">=</span><span class="p">[]</span> <span class="c"># list recording the distance evolution</span>

    <span class="c"># -- Minimizing the sum of the squares of the distances between each points in &#39;X&#39; and the median.</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="ow">not</span> <span class="n">convergence</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">numIter</span><span class="p">)</span> <span class="p">):</span>
        <span class="n">num_x</span><span class="p">,</span> <span class="n">num_y</span><span class="p">,</span> <span class="n">num_z</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">denum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="n">div</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
            <span class="n">num_x</span> <span class="o">+=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">div</span>
            <span class="n">num_y</span> <span class="o">+=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">div</span>
            <span class="n">num_z</span> <span class="o">+=</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">div</span>
            <span class="n">denum</span> <span class="o">+=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">div</span>
            <span class="n">d</span> <span class="o">+=</span> <span class="n">div</span><span class="o">**</span><span class="mi">2</span> <span class="c"># distance (to the median) to miminize</span>
        <span class="n">dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="c"># update of the distance evolution</span>
        
        <span class="k">if</span> <span class="n">denum</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s">&quot;Couldn&#39;t compute a geometric median, please check your data!&quot;</span> <span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_x</span><span class="o">/</span><span class="n">denum</span><span class="p">,</span> <span class="n">num_y</span><span class="o">/</span><span class="n">denum</span><span class="p">,</span> <span class="n">num_z</span><span class="o">/</span><span class="n">denum</span><span class="p">]</span> <span class="c"># update to the new value of the median</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">convergence</span><span class="o">=</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">)</span> <span class="c"># we test the convergence over three steps for stability</span>
            <span class="c">#~ print abs(dist[i]-dist[i-2]), convergence</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">numIter</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s">&quot;The Weiszfeld&#39;s algoritm did not converged after&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">numIter</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;iterations !!!!!!!!!&quot;</span> <span class="p">)</span>
    <span class="c"># -- When convergence or iterations limit is reached we assume that we found the median.</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="are_these_labels_neighbors"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.are_these_labels_neighbors">[docs]</a><span class="k">def</span> <span class="nf">are_these_labels_neighbors</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function allows you to make sure the provided labels are all connected neighbors according to a known neighborhood.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intersection</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">inter</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">[</span><span class="n">label</span><span class="p">])</span><span class="o">&amp;</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="c"># it&#39;s possible that `neighborhood` does not have key `label`</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">inter</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">inter</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">([</span><span class="n">label</span><span class="p">]):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">inter</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
            <span class="n">intersection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">intersection</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="SpatialImageAnalysis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.SpatialImageAnalysis">[docs]</a><span class="k">def</span> <span class="nf">SpatialImageAnalysis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructeur. Detect automatically if the image is 2D or 3D.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#~ print args, kwd</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="c"># -- Check if the image is 2D</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SpatialImageAnalysis2D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwd</span><span class="p">)</span>
    <span class="c"># -- Else it&#39;s considered as a 3D image.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SpatialImageAnalysis3D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwd</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="read_id_list"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.read_id_list">[docs]</a><span class="k">def</span> <span class="nf">read_id_list</span><span class="p">(</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a *.txt file containing a list of ids separated by `sep`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    
    <span class="n">k</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    
    <span class="n">list_cell</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">list_cell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">list_cell</span>

</div>
<div class="viewcode-block" id="save_id_list"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.save_id_list">[docs]</a><span class="k">def</span> <span class="nf">save_id_list</span><span class="p">(</span><span class="n">id_list</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a *.txt file containing a list of ids separated by `sep`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="projection_matrix"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.projection_matrix">[docs]</a><span class="k">def</span> <span class="nf">projection_matrix</span><span class="p">(</span><span class="n">point_set</span><span class="p">,</span> <span class="n">subspace_rank</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the projection matrix of a set of point depending on the subspace rank.</span>
<span class="sd">    </span>
<span class="sd">    :Parameters:</span>
<span class="sd">     - point_set (np.array): list of coordinates of shape (n_point, init_dim).</span>
<span class="sd">     - dimension_reduction (int) : the dimension reduction to apply</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">point_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_set</span><span class="p">)</span>
    <span class="n">nb_coord</span> <span class="o">=</span> <span class="n">point_set</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">init_dim</span> <span class="o">=</span> <span class="n">point_set</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">init_dim</span> <span class="o">&gt;</span> <span class="n">subspace_rank</span>
    <span class="k">assert</span> <span class="n">subspace_rank</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">centroid</span> <span class="o">=</span> <span class="n">point_set</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># - Compute the centered matrix:</span>
        <span class="n">centered_point_set</span> <span class="o">=</span> <span class="n">point_set</span> <span class="o">-</span> <span class="n">centroid</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">centered_point_set</span> <span class="o">=</span> <span class="n">point_set</span>
    
    <span class="c"># -- Compute the Singular Value Decomposition (SVD) of centered coordinates:</span>
    <span class="n">U</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">centered_point_set</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span>

    <span class="c"># -- Compute the projection matrix:</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">subspace_rank</span><span class="p">],</span> <span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">subspace_rank</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">H</span>
</div>
<div class="viewcode-block" id="random_color_dict"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.analysis.random_color_dict">[docs]</a><span class="k">def</span> <span class="nf">random_color_dict</span><span class="p">(</span><span class="n">list_cell</span><span class="p">,</span> <span class="n">alea_range</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a dict where keys -from a given list `list_cell`- receive a random integer from the list as value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alea_range</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span> <span class="n">list_cell</span><span class="p">,</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alea_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_cell</span><span class="p">))]</span> <span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alea_range</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alea_range</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span> <span class="n">list_cell</span><span class="p">,</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">alea_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alea_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_cell</span><span class="p">))]</span> <span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span> <span class="n">list_cell</span><span class="p">,</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_cell</span><span class="p">))]</span> <span class="p">))</span>

<span class="c">#~ def OLS_wall(xyz):</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ Compute OLS (Ordinary Least Square) fitting of a plane in a 3D space.</span>
    <span class="c">#~ </span>
    <span class="c">#~ :Parameters:</span>
        <span class="c">#~ - `xyz` voxels coordinate (3xN or Nx3 matrix)</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ if xyz.shape()[0] == 3: #if the matrix is 3xN, we convert it to a Nx3 matrix.</span>
        <span class="c">#~ xyz = xyz.transpose()</span>
    <span class="c">#~ </span>
    <span class="c">#~ ols_fit = ln.lstsq( xyz[:,0:2], xyz[:,2] )</span>
        <span class="c">#~ </span>
    <span class="c">#~ return ols_fit</span>

    <span class="c">#~ def mask_intersection(self, vid, geometric_mask):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ Create the intersection between a geometric_mask and de first layer of voxel of the image.</span>
        <span class="c">#~ Used for curvature computation.</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ x_max, y_max, z_max = self.first_voxel_layer().shape</span>
        <span class="c">#~ x_size, y_size, z_size = geometric_mask.shape</span>
        <span class="c">#~ if (x_size &gt;= x_max) or (y_size &gt;= y_max) or (z_size &gt;= z_max):</span>
            <span class="c">#~ if verbose: print &#39;the size of the geometrical object is too big !!!&#39;</span>
            <span class="c">#~ return None</span>
<span class="c">#~ </span>
        <span class="c">#~ from openalea.image.all import geometric_median</span>
        <span class="c">#~ x, y, z = np.where(self.first_voxel_layer() == vid)</span>
        <span class="c">#~ median = geometric_median( np.array([list(x),list(y),list(z)]) )</span>
        <span class="c">#~ </span>
        <span class="c">#~ integers=np.vectorize(integer)</span>
        <span class="c">#~ median = integers(median)</span>
        <span class="c">#~ </span>
        <span class="c">#~ x_bar, y_bar, z_bar = integers(np.round(np.array(geometric_mask.shape)/2.))</span>
        <span class="c">#~ # -- We create the mask (with extended border so the geometrical mask can be applied even if it&#39;s center is close from the margins of the image)</span>
        <span class="c">#~ mask = np.zeros( tuple([x_max+x_size, y_max+y_size, z_max+z_size]) )</span>
        <span class="c">#~ # -- We create the extended version of the image</span>
        <span class="c">#~ image = copy.copy(mask)</span>
        <span class="c">#~ image[ x_bar:x_max+x_bar,y_bar:y_max+y_bar,z_bar:z_max+z_bar ] = self.first_voxel_layer()</span>
        <span class="c">#~ # -- We now add the geometric_mask to the mask</span>
        <span class="c">#~ mask[median[0]:median[0]+x_size,median[1]:median[1]+y_size,median[2]:median[2]+z_size] = geometric_mask</span>
        <span class="c">#~ # -- We now applay the geometric_mask to the image</span>
        <span class="c">#~ image = image * mask</span>
        <span class="c">#~ image[image==1] = 0</span>
        <span class="c">#~ </span>
        <span class="c">#~ return  image[ x_bar:x_max+x_bar,y_bar:y_max+y_bar,z_bar:z_max+z_bar ]</span>


    <span class="c">#~ def __curvature_parameters2(func):</span>
        <span class="c">#~ def wrapped_function(self, vids = None, sphere_size = 50, verbose = False):</span>
            <span class="c">#~ &quot;&quot;&quot;</span>
            <span class="c">#~ &quot;&quot;&quot;</span>
            <span class="c">#~ # -- We start by taking out the border cells (we could keep them and to prevent the computation of the curvature for neighbours of margin cells)</span>
            <span class="c">#~ if self.cells_in_image_margins() != [0, 1]:</span>
                <span class="c">#~ self.remove_margins_cells(verbose = verbose)</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- If &#39;vids&#39; is an integer... </span>
            <span class="c">#~ if isinstance(vids,int):</span>
                <span class="c">#~ if (vids not in self.L1()): # - ...but not in the L1 list, there is nothing to do!</span>
                    <span class="c">#~ print &quot;Cell&quot;,vids,&quot;is not in the L1. We won&#39;t compute it&#39;s curvature.&quot;</span>
                    <span class="c">#~ return 0</span>
                <span class="c">#~ else: # - ... and in the L1 list, we make it iterable.</span>
                    <span class="c">#~ vids=[vids]</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- If &#39;vids&#39; is a list, we make sure to keep only its &#39;vid&#39; present in the L1 list!</span>
            <span class="c">#~ if isinstance(vids,list):</span>
                <span class="c">#~ tmp = copy.deepcopy(vids) # Ensure to scan all the elements of &#39;vids&#39;</span>
                <span class="c">#~ for vid in tmp:</span>
                    <span class="c">#~ if vid not in self.L1():</span>
                        <span class="c">#~ if verbose: print &quot;Cell&quot;,vid,&quot;is not in the L1. We won&#39;t compute it&#39;s curvature.&quot;</span>
                        <span class="c">#~ vids.remove(vid)</span>
                <span class="c">#~ if len(vids) == 0: # if there is no element left in the &#39;vids&#39; list, there is nothing to do!</span>
                    <span class="c">#~ print &#39;None of the cells you provided bellonged to the L1.&#39;</span>
                    <span class="c">#~ return 0</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- If &#39;vids&#39; is `None`, we apply the function to all L1 cells:</span>
            <span class="c">#~ if vids == None:</span>
                <span class="c">#~ vids = self.L1()</span>
<span class="c">#~ </span>
            <span class="c">#~ sphere = euclidean_sphere(sphere_size)</span>
<span class="c">#~ </span>
            <span class="c">#~ if create_route_for_fitting:</span>
                <span class="c">#~ create_route_for_fitting(vids) # Sort vids in a ways its you have a neighbors with estimated parameters for the quadratic plane.</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- Now we can compute the curvature by applying the function &#39;gaussian_curvature&#39; OR &#39;mean_curvature&#39;.</span>
            <span class="c">#~ curvature={}</span>
            <span class="c">#~ if verbose: print &#39;Computing curvature :&#39;</span>
            <span class="c">#~ for n,vid in enumerate(vids):</span>
                <span class="c">#~ if verbose: print n,&#39;/&#39;,len(vids)</span>
                <span class="c">#~ if self.quadratic_parameters.has_key(vid): # if we already know the parameters of the quadratic plane, no need to search for the external wall.</span>
                    <span class="c">#~ if self.principal_curvatures.has_key(vid):</span>
                        <span class="c">#~ k1, k2 = self.principal_curvatures[vid]</span>
                    <span class="c">#~ else:</span>
                        <span class="c">#~ k1, k2 = principal_curvatures(self.quadratic_parameters[vid])</span>
                        <span class="c">#~ self.principal_curvatures[vid] = [k1, k2]</span>
                <span class="c">#~ else:</span>
                    <span class="c">#~ masked_im = self.mask_intersection(vid,sphere)</span>
                    <span class="c">#~ x, y, z = np.where( masked_im != 0 )</span>
                    <span class="c">#~ params = quadratic_plane_fit(x,y,z)[0]</span>
                    <span class="c">#~ self.quadratic_parameters[vid] = params</span>
                    <span class="c">#~ k1, k2 = principal_curvatures(params)</span>
                    <span class="c">#~ self.principal_curvatures[vid] = [k1, k2]</span>
                <span class="c">#~ curvature[vid] = func( k1,k2 )</span>
            <span class="c">#~ </span>
            <span class="c">#~ return curvature</span>
        <span class="c">#~ return wrapped_function</span>


    <span class="c">#~ @__curvature_parameters2</span>
    <span class="c">#~ def gaussian_curvature2( k1, k2 ):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ Gaussian curvature is the product of principal curvatures &#39;k1*k2&#39;.</span>
        <span class="c">#~ Here it comes from the first and second fundamental form of a quadratic plane fitted by nonlinear least square method.</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ return k1*k2</span>


    <span class="c">#~ @__curvature_parameters2</span>
    <span class="c">#~ def mean_curvature2( k1, k2 ):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ Gaussian curvature is the product of principal curvatures &#39;&#39;1/2*(k1+k2)&#39;.</span>
        <span class="c">#~ Here it comes from the first and second fundamental form of a quadratic plane fitted by nonlinear least square method.</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ return 0.5*(k1+k2)</span>


    <span class="c">#~ def neighborhood_surface_walls(self, vid, all_walls = None, verbose = False):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ if all_walls == None:</span>
            <span class="c">#~ all_walls = self.walls_voxels(1,verbose)</span>
<span class="c">#~ </span>
        <span class="c">#~ walls = []</span>
        <span class="c">#~ walls.append(all_walls[1,vid])</span>
        <span class="c">#~ L1 = self.L1()</span>
        <span class="c">#~ for k in self.neighbors(vid):</span>
            <span class="c">#~ if k in L1:</span>
                <span class="c">#~ walls.append( all_walls[1,k] )</span>
<span class="c">#~ </span>
        <span class="c">#~ return walls</span>


    <span class="c">#~ def brute_route_by_neighbors(self, id2list, starting_point = None, verbose = False):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ Function returning a list of vids. It define a sequence of labels allowing to travel in a neighbors-like manner.</span>
        <span class="c">#~ </span>
        <span class="c">#~ If return 0: the id2list do not define a connected region.</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ if verbose: print &#39;Creating a route by neighbors...&#39;</span>
        <span class="c">#~ remaining_labels = copy.deepcopy(id2list)</span>
        <span class="c">#~ if 0 in remaining_labels: remaining_labels.remove(0)</span>
        <span class="c">#~ if 1 in remaining_labels: remaining_labels.remove(1)</span>
<span class="c">#~ </span>
        <span class="c">#~ if starting_point == None:</span>
            <span class="c">#~ starting_point = remaining_labels[0]</span>
<span class="c">#~ </span>
        <span class="c">#~ if starting_point in remaining_labels:</span>
            <span class="c">#~ remaining_labels.remove(starting_point)</span>
        <span class="c">#~ else:</span>
            <span class="c">#~ print &#39;The starting point you provided is not in the L1!&#39;</span>
            <span class="c">#~ return 0</span>
<span class="c">#~ </span>
        <span class="c">#~ max_iter = len(remaining_labels)</span>
        <span class="c">#~ </span>
        <span class="c">#~ all_neighbors=self.neighbors()</span>
        <span class="c">#~ </span>
        <span class="c">#~ route=[]</span>
        <span class="c">#~ route.extend([starting_point])</span>
        <span class="c">#~ nb_iter = 0</span>
        <span class="c">#~ while len(remaining_labels) != 0 :</span>
            <span class="c">#~ neighbors = all_neighbors[starting_point]</span>
            <span class="c">#~ neighbors = list( set(remaining_labels)&amp;set(neighbors) )</span>
            <span class="c">#~ route.extend(neighbors)</span>
            <span class="c">#~ remaining_labels = list( set(remaining_labels)-set(neighbors) )</span>
            <span class="c">#~ for k in neighbors:</span>
                <span class="c">#~ n = list( set(remaining_labels)&amp;set(all_neighbors[k]) )</span>
                <span class="c">#~ route.extend(n)</span>
                <span class="c">#~ remaining_labels = list( set(remaining_labels)-set(n) )</span>
            <span class="c">#~ </span>
            <span class="c">#~ back = 1</span>
            <span class="c">#~ starting_point = route[len(route)-back]</span>
            <span class="c">#~ while (len( set(remaining_labels)&amp;set(all_neighbors[starting_point]) ) == 0) &amp; (len(remaining_labels) != 0):</span>
                <span class="c">#~ back +=1</span>
                <span class="c">#~ starting_point = route[len(route)-back]</span>
<span class="c">#~ </span>
            <span class="c">#~ nb_iter += 1</span>
            <span class="c">#~ if nb_iter &gt;= max_iter:</span>
                <span class="c">#~ print &#39;There might be a problem: you maxed-up the number of iterations (&#39;,max_iter,&#39;).&#39;</span>
                <span class="c">#~ print &#39;remaining_labels&#39;,remaining_labels</span>
                <span class="c">#~ print &#39;Computed route so far:&#39;, route</span>
                <span class="c">#~ return 0</span>
<span class="c">#~ </span>
        <span class="c">#~ return route</span>


    <span class="c">#~ def __curvature_parameters3(func):</span>
        <span class="c">#~ def wrapped_function(self, vids = None, radius = 50, verbose = False):</span>
            <span class="c">#~ &quot;&quot;&quot;</span>
            <span class="c">#~ &quot;&quot;&quot;</span>
            <span class="c">#~ # -- We start by taking out the border cells (we could keep them and to prevent the computation of the curvature for neighbours of margin cells)</span>
            <span class="c">#~ if self.cells_in_image_margins() != [0, 1]:</span>
                <span class="c">#~ self.remove_margins_cells(verbose = verbose)</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- If &#39;vids&#39; is an integer... </span>
            <span class="c">#~ if isinstance(vids,int):</span>
                <span class="c">#~ if (vids not in self.L1()): # - ...but not in the L1 list, there is nothing to do!</span>
                    <span class="c">#~ print &quot;Cell&quot;,vids,&quot;is not in the L1. We won&#39;t compute it&#39;s curvature.&quot;</span>
                    <span class="c">#~ return 0</span>
                <span class="c">#~ else: # - ... and in the L1 list, we make it iterable.</span>
                    <span class="c">#~ vids=[vids]</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- If &#39;vids&#39; is a list, we make sure to keep only its &#39;vid&#39; present in the L1 list!</span>
            <span class="c">#~ if isinstance(vids,list):</span>
                <span class="c">#~ tmp = copy.deepcopy(vids) # Ensure to scan all the elements of &#39;vids&#39;</span>
                <span class="c">#~ for vid in tmp:</span>
                    <span class="c">#~ if vid not in self.L1():</span>
                        <span class="c">#~ if verbose: print &quot;Cell&quot;,vid,&quot;is not in the L1. We won&#39;t compute it&#39;s curvature.&quot;</span>
                        <span class="c">#~ vids.remove(vid)</span>
                <span class="c">#~ if len(vids) == 0: # if there is no element left in the &#39;vids&#39; list, there is nothing to do!</span>
                    <span class="c">#~ print &#39;None of the cells you provided bellonged to the L1.&#39;</span>
                    <span class="c">#~ return 0</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- If &#39;vids&#39; is `None`, we apply the function to all L1 cells:</span>
            <span class="c">#~ if vids == None:</span>
                <span class="c">#~ vids = self.L1()</span>
<span class="c">#~ </span>
            <span class="c">#~ # -- Now we can compute the curvature by applying the function &#39;gaussian_curvature&#39; OR &#39;mean_curvature&#39;.</span>
            <span class="c">#~ curvature={}</span>
            <span class="c">#~ if verbose: print &#39;Computing curvature :&#39;</span>
            <span class="c">#~ for n,vid in enumerate(vids):</span>
                <span class="c">#~ if verbose: print n,&#39;/&#39;,len(vids)</span>
                <span class="c">#~ if self.quadratic_parameters.has_key(vid): # if we already know the parameters of the quadratic plane, no need to search for the external wall.</span>
                    <span class="c">#~ if self.principal_curvatures.has_key(vid):</span>
                        <span class="c">#~ k1, k2 = self.principal_curvatures[vid]</span>
                    <span class="c">#~ else:</span>
                        <span class="c">#~ k1, k2 = principal_curvatures(self.quadratic_parameters[vid])</span>
                        <span class="c">#~ self.principal_curvatures[vid] = [k1, k2]</span>
                <span class="c">#~ else:</span>
                    <span class="c">#~ x, y, z = self.voxel_neighborhood(vid,radius)</span>
                    <span class="c">#~ params = quadratic_plane_fit(x,y,z)[0]</span>
                    <span class="c">#~ self.quadratic_parameters[vid] = params</span>
                    <span class="c">#~ k1, k2 = principal_curvatures(params)</span>
                    <span class="c">#~ self.principal_curvatures[vid] = [k1, k2]</span>
                <span class="c">#~ curvature[vid] = func( k1,k2 )</span>
            <span class="c">#~ </span>
            <span class="c">#~ return curvature</span>
        <span class="c">#~ return wrapped_function</span>


<span class="c">#~ @__curvature_parameters3</span>
    <span class="c">#~ def gaussian_curvature3( k1, k2 ):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ Gaussian curvature is the product of principal curvatures &#39;k1*k2&#39;.</span>
        <span class="c">#~ Here it comes from the first and second fundamental form of a quadratic plane fitted by nonlinear least square method.</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ return k1*k2</span>


    <span class="c">#~ @__curvature_parameters3</span>
    <span class="c">#~ def mean_curvature3( k1, k2 ):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ Gaussian curvature is the product of principal curvatures &#39;&#39;1/2*(k1+k2)&#39;.</span>
        <span class="c">#~ Here it comes from the first and second fundamental form of a quadratic plane fitted by nonlinear least square method.</span>
        <span class="c">#~ &quot;&quot;&quot;</span>


    <span class="c">#~ def voxel_neighborhood(self, vid, radius = 40., origin = &#39;Mean&#39;):</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ Function returning the connected voxels to the one closest to the &#39;Mean&#39; or &#39;Median&#39; of the voxels cloud of cell &#39;vid&#39;.</span>
        <span class="c">#~ &quot;&quot;&quot;</span>
        <span class="c">#~ if self._first_voxel_layer == None:</span>
            <span class="c">#~ self.first_voxel_layer(1, True, keep_background = False)</span>
        <span class="c">#~ else:</span>
            <span class="c">#~ if self._first_voxel_layer[0,0,0]==1:</span>
                <span class="c">#~ self._first_voxel_layer[self._first_voxel_layer==1]=0</span>
                <span class="c">#~ </span>
        <span class="c">#~ pts = [tuple([int(x[i]),int(y[i]),int(z[i])]) for i in xrange(len(x))]</span>
<span class="c">#~ </span>
        <span class="c">#~ from openalea.plantgl.all import k_closest_points_from_ann, r_neighborhood</span>
        <span class="c">#~ # adjacencies = k_closest_points_from_delaunay(pts,k=10)</span>
        <span class="c">#~ adjacencies = k_closest_points_from_ann(pts,k=10)</span>
<span class="c">#~ </span>
        <span class="c">#~ from openalea.image.all import geometric_median</span>
        <span class="c">#~ x_vid, y_vid, z_vid = np.where(self.first_voxel_layer() == vid)</span>
        <span class="c">#~ if origin == &#39;median&#39;:</span>
            <span class="c">#~ median = geometric_median( np.array([list(x_vid),list(y_vid),list(z_vid)]) )</span>
        <span class="c">#~ else:</span>
            <span class="c">#~ median = np.mean( np.array([list(x_vid),list(y_vid),list(z_vid)]) )</span>
<span class="c">#~ </span>
        <span class="c">#~ integers=np.vectorize(integer)</span>
        <span class="c">#~ median = integers(median)</span>
        <span class="c">#~ pts_vid = [tuple([int(x_vid[i]),int(y_vid[i]),int(z_vid[i])]) for i in xrange(len(x_vid))]</span>
<span class="c">#~ </span>
        <span class="c">#~ min_dist = closest_from_A(median, pts_vid)</span>
<span class="c">#~ </span>
        <span class="c">#~ neigborids = r_neighborhood(pts.index(min_dist), pts, adjacencies, radius)</span>
<span class="c">#~ </span>
        <span class="c">#~ neigbor_pts=[]</span>
        <span class="c">#~ for i in neigborids:</span>
            <span class="c">#~ neigbor_pts.append(pts[i])</span>
<span class="c">#~ </span>
        <span class="c">#~ neigbor_pts</span>
<span class="c">#~ </span>
        <span class="c">#~ x_pts, y_pts, z_pts=[],[],[]</span>
        <span class="c">#~ for i in neigborids:</span>
            <span class="c">#~ x_pts.append(pts[i][0])</span>
            <span class="c">#~ y_pts.append(pts[i][1])</span>
            <span class="c">#~ z_pts.append(pts[i][2])</span>
        <span class="c">#~ </span>
        <span class="c">#~ return x_pts, y_pts, z_pts</span>


<span class="c">#~ def second_order_surface(params,data):</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ A second order analytic surface of the form z = a1.x^2 + a2.xy + a3.y^2 + a4.x + a5.y + a6</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ a1,a2,a3,a4,a5,a6=params</span>
    <span class="c">#~ x,y=data</span>
    <span class="c">#~ return (a1*x**2 + a2*x*y + a3*y**2 + a4*x + a5*y + a6)</span>
<span class="c">#~ </span>
<span class="c">#~ </span>
<span class="c">#~ def quadratic_plane_fit( x, y, z, fit_init = [0,0,0,0,0,1] ):</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ Use non-linear least squares to fit a function, f, to data. The algorithm uses the Levenburg-Marquardt algorithm.</span>
    <span class="c">#~ The function to be fitted will be called with two parameters:</span>
        <span class="c">#~ - the first is a tuple containing all fit parameters, </span>
        <span class="c">#~ - the second is the first element of a data point. The return value must be a number.</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ import Scientific </span>
    <span class="c">#~ from Scientific.Functions.LeastSquares import leastSquaresFit</span>
<span class="c">#~ </span>
    <span class="c">#~ if fit_init == None:</span>
        <span class="c">#~ fit_init = [0,0,0,0,0,1]</span>
<span class="c">#~ </span>
    <span class="c">#~ # --The first element specifies the independent variables of the model. </span>
    <span class="c">#~ # --The second element of each data point tuple is the number that the return value of the model function is supposed to match</span>
    <span class="c">#~ wall=[tuple(( tuple((x[i],y[i])), z[i] )) for i in xrange(len(x))]</span>
    <span class="c">#~ </span>
    <span class="c">#~ optimal_parameter_values, chi_squared=leastSquaresFit(second_order_surface, fit_init, wall, max_iterations=None)</span>
    <span class="c">#~ </span>
    <span class="c">#~ return optimal_parameter_values, chi_squared</span>


<span class="c">#~ def principal_curvatures(params, return_roots = False):</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ Compute principal curvature k1 and k2 from a second order analytic surface of the form z = a1.x^2 + a2.xy + a3.y^2 + a4.x + a5.y + a6.</span>
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ # -- We first recover the parameters:</span>
    <span class="c">#~ a1,a2,a3,a4,a5,a6=params</span>
    <span class="c">#~ </span>
    <span class="c">#~ # -- Then we define the parameters E, F and G for the first fundamental form:</span>
    <span class="c">#~ E=1+a4**2</span>
    <span class="c">#~ F=a4*a5</span>
    <span class="c">#~ G=1+a5**2</span>
    <span class="c">#~ </span>
    <span class="c">#~ # -- Then we define the parameters e, f and g for the second fundamental form:    </span>
    <span class="c">#~ e=(2*a1)/(math.sqrt(E*G-F**2))</span>
    <span class="c">#~ f=(a2)/(math.sqrt(E*G-F**2))</span>
    <span class="c">#~ g=(2*a3)/(math.sqrt(E*G-F**2))</span>
    <span class="c">#~ </span>
    <span class="c">#~ # -- We now have to find the roots of the equation : (Fg - Gf) x**2 + (Eg - Ge) x + (Ef - Fe) = 0</span>
    <span class="c">#~ a = (F*g - G*f)</span>
    <span class="c">#~ b = (E*g - G*e)</span>
    <span class="c">#~ c = (E*f - F*e)</span>
    <span class="c">#~ discriminant = b**2 - 4*a*c</span>
    <span class="c">#~ if discriminant &gt; 0:</span>
        <span class="c">#~ x_1 = ( -b-math.sqrt(discriminant) )/(2*a)</span>
        <span class="c">#~ x_2 = ( -b+math.sqrt(discriminant) )/(2*a)</span>
    <span class="c">#~ elif discriminant == 0:</span>
        <span class="c">#~ x_1 = x_2 = (-b)/(2*a)</span>
    <span class="c">#~ else:</span>
        <span class="c">#~ import warnings</span>
        <span class="c">#~ warnings.warn(&quot;No real solutions...&quot;)</span>
        <span class="c">#~ return 0,0</span>
        <span class="c">#~ </span>
    <span class="c">#~ if return_roots:</span>
        <span class="c">#~ return (e+f*x_1)/(E+F*x_1), (e+f*x_2)/(E+F*x_2), x_1, x_2</span>
    <span class="c">#~ else:</span>
        <span class="c">#~ return (e+f*x_1)/(E+F*x_1), (e+f*x_2)/(E+F*x_2)</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">OpenAlea community website</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, INRIA VirtualPlants.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3a0.
    </div>
  </body>
</html>