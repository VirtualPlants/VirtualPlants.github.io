<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>image.algo.temporal_graph_from_image &mdash; OpenAlea community website</title>
    
    <link rel="stylesheet" href="../../../_static/virtualplants.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenAlea community website" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">OpenAlea community website</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for image.algo.temporal_graph_from_image</h1><div class="highlight"><pre>
<span class="c"># -*- python -*-</span>
<span class="c">#</span>
<span class="c">#       OpenAlea.image.algo</span>
<span class="c">#</span>
<span class="c">#       Copyright 2012 INRIA - CIRAD - INRA</span>
<span class="c">#</span>
<span class="c">#       File author(s):  Jonathan Legrand &lt;jonathan.legrand@ens-lyon.fr&gt;</span>
<span class="c">#                        Frederic Boudon &lt;frederic.boudon@cirad.fr&gt;</span>
<span class="c">#</span>
<span class="c">#       Distributed under the Cecill-C License.</span>
<span class="c">#       See accompanying file LICENSE.txt or copy at</span>
<span class="c">#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html</span>
<span class="c">#</span>
<span class="c">#       OpenAlea WebSite: http://openalea.gforge.inria.fr</span>
<span class="c">#</span>
<span class="c">################################################################################</span>
<span class="sd">&quot;&quot;&quot;This module helps to create PropertyGraph from SpatialImages.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="kn">as</span> <span class="nn">cp</span>
<span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>

<span class="kn">from</span> <span class="nn">openalea.image.serial.basics</span> <span class="kn">import</span> <span class="n">SpatialImage</span><span class="p">,</span> <span class="n">imread</span>
<span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">SpatialImageAnalysis</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">,</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">find_wall_median_voxel</span><span class="p">,</span> <span class="n">sort_boundingbox</span><span class="p">,</span> <span class="n">projection_matrix</span>
<span class="kn">from</span> <span class="nn">openalea.image.spatial_image</span> <span class="kn">import</span> <span class="n">is2D</span>
<span class="kn">from</span> <span class="nn">openalea.container</span> <span class="kn">import</span> <span class="n">PropertyGraph</span>
<span class="kn">from</span> <span class="nn">openalea.container</span> <span class="kn">import</span> <span class="n">TemporalPropertyGraph</span>
<span class="kn">from</span> <span class="nn">openalea.container.temporal_graph_analysis</span> <span class="kn">import</span> <span class="n">translate_ids_Graph2Image</span><span class="p">,</span> <span class="n">translate_keys_Graph2Image</span>

<span class="kn">from</span> <span class="nn">openalea.image.registration.registration</span> <span class="kn">import</span> <span class="n">pts2transfo</span>


<div class="viewcode-block" id="find_daugthers_barycenters"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.find_daugthers_barycenters">[docs]</a><span class="k">def</span> <span class="nf">find_daugthers_barycenters</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">reference_image</span><span class="p">,</span> <span class="n">reference_tp</span><span class="p">,</span> <span class="n">tp_2register</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">real_world_units</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on a TemporalPropertyGraph (lineage info), this script find the barycenter of &#39;fused daughter&#39; cells between `reference_tp` &amp; `tp_2register`.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `graph` (TemporalPropertyGraph) - a TemporalPropertyGraph used for the lineage information</span>
<span class="sd">     - `reference_image` (AbstractSpatialImageAnalysis|SpatialImage|str) - segmented image of the reference time point used to compute barycenters</span>
<span class="sd">     - `reference_tp` (int) - the</span>
<span class="sd">     - `tp_2register` (int) -</span>
<span class="sd">     - `real_world_units` (bool) -</span>

<span class="sd">    :Returns:</span>
<span class="sd">     - a dictionary where *keys= vids and *values= 3x1 vectors of coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">SpI_ids</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">vids</span><span class="p">)</span>
    <span class="c"># -- **kwargs options:</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">background</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;background&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">background</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;verbose&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">reference_image</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">reference_image</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">reference_image</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Could not determine the type of the `image`...&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">new_barycenters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">print</span> <span class="s">&quot;Computing &#39;fused daugther&#39; barycenters:&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vids</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">vid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vids</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;{}%...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span><span class="o">+=</span><span class="mi">10</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
        <span class="n">graph_children</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">reference_tp</span><span class="o">-</span><span class="n">tp_2register</span><span class="p">)</span> <span class="o">-</span> <span class="n">graph</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">reference_tp</span><span class="o">-</span><span class="n">tp_2register</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">SpI_children</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">graph_children</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="p">[],[],[]</span>
        <span class="k">for</span> <span class="n">id_child</span> <span class="ow">in</span> <span class="n">SpI_children</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">id_child</span><span class="p">)])</span> <span class="o">==</span> <span class="n">id_child</span> <span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">id_child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">id_child</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">z</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">id_child</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">real_world_units</span><span class="p">:</span>
            <span class="n">new_barycenters</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">analysis</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_barycenters</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">t_stop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;Time to find &#39;fused daughter&#39; barycenters: {}s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_stop</span><span class="o">-</span><span class="n">t_start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">translate_keys_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">new_barycenters</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="image_registration"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.image_registration">[docs]</a><span class="k">def</span> <span class="nf">image_registration</span><span class="p">(</span><span class="n">image_2register</span><span class="p">,</span> <span class="n">ref_points</span><span class="p">,</span> <span class="n">reg_points</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Register an image according to `ref_points` &amp; `reg_points`.</span>
<span class="sd">    Interpolation methods is set to &#39;nearest&#39; by default, but this can be changed by adding an &#39;interpolation_method&#39; as kwargs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">vplants.asclepios.vt_exec</span> <span class="kn">import</span> <span class="n">reech3d</span>

    <span class="n">ref_points</span><span class="p">,</span> <span class="n">reg_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_points</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">reg_points</span><span class="p">)</span>
    <span class="n">registration</span> <span class="o">=</span> <span class="n">pts2transfo</span><span class="p">(</span><span class="n">ref_points</span><span class="p">,</span> <span class="n">reg_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;interpolation_method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;interpolation_method&#39;</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">interpolation_method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;interpolation_method&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interpolation_method</span> <span class="o">=</span> <span class="s">&quot;nearest&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">im_reech</span> <span class="o">=</span> <span class="n">reech3d</span><span class="o">.</span><span class="n">reech3d</span><span class="p">(</span><span class="n">image_2register</span><span class="p">,</span> <span class="n">mat</span><span class="o">=</span><span class="n">registration</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation_method</span><span class="p">,</span> <span class="n">vin</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">voxelsize</span><span class="p">,</span> <span class="n">vout</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">voxelsize</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">im_reech</span> <span class="o">=</span> <span class="n">reech3d</span><span class="o">.</span><span class="n">reech3d</span><span class="p">(</span><span class="n">image_2register</span><span class="p">,</span> <span class="n">mat</span><span class="o">=</span><span class="n">registration</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation_method</span><span class="p">,</span> <span class="n">vin</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">vout</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;t_2def&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;t_ref&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">t_2def</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;t_2def&#39;</span><span class="p">]</span>
        <span class="n">t_ref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;t_ref&#39;</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s">&#39;pts_{}{}_{}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">reg_points</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s">&#39;pts_{}{}_{}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">ref_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">&#39;save_registered_image&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s">&#39;t_2def&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;t_ref&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">imsave</span><span class="p">(</span><span class="s">&#39;t{}_on_t{}.inr.gz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">im_reech</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im_reech</span>

</div>
<div class="viewcode-block" id="scipy_image_registration"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.scipy_image_registration">[docs]</a><span class="k">def</span> <span class="nf">scipy_image_registration</span><span class="p">(</span><span class="n">image_2register</span><span class="p">,</span> <span class="n">ref_points</span><span class="p">,</span> <span class="n">reg_points</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Register an image according to `ref_points` &amp; `reg_points`.</span>
<span class="sd">    Interpolation methods is set to &#39;nearest&#39; by default, but this can be changed by adding an &#39;interpolation_method&#39; as kwargs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="kn">import</span> <span class="n">affine_transform</span>

    <span class="n">ref_points</span><span class="p">,</span> <span class="n">reg_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_points</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">reg_points</span><span class="p">)</span>
    <span class="n">registration</span> <span class="o">=</span> <span class="n">pts2transfo</span><span class="p">(</span><span class="n">ref_points</span><span class="p">,</span> <span class="n">reg_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;interpolation_method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;interpolation_method&#39;</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">interpolation_method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;interpolation_method&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interpolation_method</span> <span class="o">=</span> <span class="s">&quot;nearest&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">im_reech</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">image_2register</span><span class="p">,</span> <span class="n">registration</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">interpolation_method</span><span class="p">,</span> <span class="n">vin</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">voxelsize</span><span class="p">,</span> <span class="n">vout</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">voxelsize</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">im_reech</span> <span class="o">=</span> <span class="n">reech3d</span><span class="o">.</span><span class="n">reech3d</span><span class="p">(</span><span class="n">image_2register</span><span class="p">,</span> <span class="n">registration</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation_method</span><span class="p">,</span> <span class="n">vin</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">vout</span><span class="o">=</span><span class="n">image_2register</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;t_2def&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;t_ref&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">t_2def</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;t_2def&#39;</span><span class="p">]</span>
        <span class="n">t_ref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;t_ref&#39;</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s">&#39;pts_{}{}_{}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">reg_points</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s">&#39;pts_{}{}_{}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">ref_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">&#39;save_registered_image&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s">&#39;t_2def&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;t_ref&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">imsave</span><span class="p">(</span><span class="s">&#39;t{}_on_t{}.inr.gz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_2def</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">t_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">im_reech</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im_reech</span>

</div>
<div class="viewcode-block" id="find_object_boundingbox"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.find_object_boundingbox">[docs]</a><span class="k">def</span> <span class="nf">find_object_boundingbox</span><span class="p">(</span><span class="n">image2crop</span><span class="p">,</span> <span class="n">ignore_cells_in_image_margins</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the smallest box surrounding the labelled object in the image `image2crop`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># -- **kwargs options:</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">background</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;background&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">background</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

    <span class="c">### Reshaping with a boundingbox (around non-margin cells):</span>
    <span class="n">def_analysis</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">image2crop</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ignore_cells_in_image_margins</span><span class="p">:</span>
        <span class="n">def_analysis</span><span class="o">.</span><span class="n">add2ignoredlabels</span><span class="p">(</span> <span class="n">def_analysis</span><span class="o">.</span><span class="n">cells_in_image_margins</span><span class="p">()</span> <span class="p">)</span>
    <span class="k">if</span> <span class="s">&#39;label2keep&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">def_analysis</span><span class="o">.</span><span class="n">add2ignoredlabels</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">def_analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;label2keep&#39;</span><span class="p">]))</span> <span class="p">)</span>
    <span class="c"># labels to make a boundingbox around:</span>
    <span class="n">labels2keep</span> <span class="o">=</span> <span class="n">def_analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
    <span class="c"># Find the surrounding bbox of the object (without `self.cells_in_image_margins()`):</span>
    <span class="n">bbox_init</span> <span class="o">=</span> <span class="n">def_analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">labels2keep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">global_box</span><span class="o">=</span><span class="p">[</span><span class="n">bbox_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">bbox_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span><span class="n">bbox_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">bbox_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span><span class="n">bbox_init</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">bbox_init</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">labels2keep</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">def_analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bbox</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">global_box</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">global_box</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="n">bbox</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">&gt;</span> <span class="n">global_box</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">global_box</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

    <span class="k">print</span> <span class="s">&quot;New boundaries for the registered image: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">global_box</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">global_box</span>

</div>
<div class="viewcode-block" id="fuse_siblings_in_image"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.fuse_siblings_in_image">[docs]</a><span class="k">def</span> <span class="nf">fuse_siblings_in_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">ref_vids</span><span class="p">,</span> <span class="n">reference_tp</span><span class="p">,</span> <span class="n">tp_2fuse</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on a TemporalPropertyGraph (lineage info), this script fuse daughters cells between `reference_tp` &amp; `tp_2fuse`.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `image` (AbstractSpatialImageAnalysis|SpatialImage|str) - segmented image of the reference time point used to compute barycenters</span>
<span class="sd">     - `graph` (TemporalPropertyGraph) - a TemporalPropertyGraph used for the lineage information</span>
<span class="sd">     - `ref_vids` (list) - the</span>
<span class="sd">     - `reference_tp` (int) - time point (in the graph) of the &#39;reference image&#39; i.e. from wher compute descendants</span>
<span class="sd">     - `tp_2fuse` (int) - time point (in the graph) to fuse descendants</span>

<span class="sd">    :Returns:</span>
<span class="sd">     - a dictionary where *keys= ref_vids and *values= 3x1 vectors of coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">SpI_ids</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ref_vids</span><span class="p">)</span>
    <span class="c"># -- **kwargs options:</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">background</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;background&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">background</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;verbose&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="c"># -- Check the type the `image` object</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">image</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Could not determine the type of the `image`...&quot;</span><span class="p">)</span>
    <span class="c"># -- &#39;fused&#39; image creation:</span>
    <span class="n">tmp_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">image</span><span class="p">))</span>
    <span class="n">tmp_img</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">tmp_img</span> <span class="o">+=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">background</span> <span class="c"># retreive the background</span>
    <span class="n">not_found</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_vids</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">vid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_vids</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">5</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100% &quot;</span><span class="p">,</span>
        <span class="n">graph_children</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="n">reference_tp</span><span class="p">)</span> <span class="o">-</span> <span class="n">graph</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="n">reference_tp</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">graph_children</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="n">not_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
        <span class="n">SpI_children</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">graph_children</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">id_child</span> <span class="ow">in</span> <span class="n">SpI_children</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">id_child</span><span class="p">)]</span> <span class="o">==</span> <span class="n">id_child</span>
            <span class="n">tmp_img</span><span class="p">[</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">id_child</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tmp_img</span><span class="p">[</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">id_child</span><span class="p">)]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">SpI_ids</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

    <span class="n">t_stop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;(elapsed time: {}s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_stop</span><span class="o">-</span><span class="n">t_start</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">not_found</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;No descendant found for these vertex ids: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">not_found</span><span class="p">))</span>
    <span class="n">tmp_img</span> <span class="o">=</span> <span class="n">SpatialImage</span><span class="p">(</span><span class="n">tmp_img</span><span class="p">)</span>
    <span class="n">tmp_img</span><span class="o">.</span><span class="n">voxelsize</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">_voxelsize</span>
    <span class="n">tmp_img</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">info</span>
    <span class="k">return</span> <span class="n">tmp_img</span>

</div>
<div class="viewcode-block" id="create_fused_image_analysis"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.create_fused_image_analysis">[docs]</a><span class="k">def</span> <span class="nf">create_fused_image_analysis</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">,</span> <span class="n">images2fuse</span><span class="o">=</span><span class="p">[],</span> <span class="n">starting_SpI_A_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_SpI_A</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on a TemporalPropertyGraph (for lineage informations), this script fuse daughters cells for `SpI_Analysis` indexed in `images2fuse`.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `graph` (TemporalPropertyGraph) - a TemporalPropertyGraph used for the lineage information</span>
<span class="sd">     - `SpI_Analysis` (list of AbstractSpatialImageAnalysis) - </span>
<span class="sd">     - `images2fuse` (list) - list giving the index of `SpI_Analysis` to fuse (e.g. 0 can not be fused !)</span>
<span class="sd">     - `starting_SpI_A_index` (int) - index of the first `SpI_Analysis` in the list regarding the time_point sequence of the `graph`</span>
<span class="sd">     - `return_SpI_A` (bool) - if False return `SpatialImage` type instead of `AbstractSpatialImageAnalysis`</span>

<span class="sd">    :Returns:</span>
<span class="sd">     - `starting_SpI_A_index` (AbstractSpatialImageAnalysis|list of AbstractSpatialImageAnalysis) - SpatialImageAnalysis or list of SpatialImageAnalysis containing the fused images</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N_SpI_A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">N_SpI_A</span><span class="o">+</span><span class="n">starting_SpI_A_index</span> <span class="o">&lt;=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">images2fuse</span><span class="o">==</span><span class="p">[]:</span>
        <span class="n">images2fuse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">starting_SpI_A_index</span><span class="p">,</span> <span class="n">N_SpI_A</span><span class="o">+</span><span class="n">starting_SpI_A_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images2fuse</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">images2fuse</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">images2fuse</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;List of time-points at wich siblings will be fused and changed to their ancestor id: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">images2fuse</span><span class="p">)</span>
    <span class="c"># - Basic paranoia (avoid wasting time computing things to get an error in the end!):</span>
    <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">images2fuse</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="c"># in the first (temporally speaking) image the cells do not have parents, thus no siblings exists and can be fused!</span>
    <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">images2fuse</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span>
    
    <span class="c"># - Start the fusion(s):</span>
    <span class="n">fused_image_analysis</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">tp_2fuse</span> <span class="ow">in</span> <span class="n">images2fuse</span><span class="p">:</span>
        <span class="n">ref_tp</span> <span class="o">=</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">print</span> <span class="s">&quot;Fusion of t{} sibling cells and relabelling with t{} parent cell id:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tp_2fuse</span><span class="p">,</span> <span class="n">ref_tp</span><span class="p">)</span>
        <span class="n">ref_vids</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">ref_tp</span><span class="p">,</span> <span class="n">as_parent</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
        <span class="c"># - &#39;Fusing&#39; daughters from `ref_tp` in `tp_2fuse`:</span>
        <span class="n">fused_image</span> <span class="o">=</span> <span class="n">fuse_siblings_in_image</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">graph</span><span class="p">,</span> <span class="n">ref_vids</span><span class="p">,</span> <span class="n">ref_tp</span><span class="p">,</span> <span class="n">tp_2fuse</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">_background</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_SpI_A</span><span class="p">:</span>
            <span class="c"># - Creating a `SpatialImageAnalysis`:</span>
            <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">fused_image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">_background</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span> <span class="o">=</span> <span class="n">fused_image</span>

    <span class="k">return</span> <span class="n">fused_image_analysis</span>

</div>
<div class="viewcode-block" id="generate_graph_topology"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.generate_graph_topology">[docs]</a><span class="k">def</span> <span class="nf">generate_graph_topology</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function generating a topological/spatial graph based on neighbors detection.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `labels` (list) - list of labels to be found in the image and added to the topological graph.</span>
<span class="sd">     - `neighborhood` (dict) - dictionary giving neighbors of each object.</span>

<span class="sd">    :Returns:</span>
<span class="sd">     - `graph` (PropertyGraph) - the topological/spatial graph.</span>
<span class="sd">     - `label2vertex` (dict) - dictionary translating labels into vertex ids (vids).</span>
<span class="sd">     - `edges` (dict) - dictionary associating an edge id to a couple of topologically/spatially related vertex.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">PropertyGraph</span><span class="p">()</span>
    <span class="n">vertex2label</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span> <span class="n">vertex2label</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">l</span>
    <span class="n">label2vertex</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">vertex2label</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>

    <span class="n">labelset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">source</span><span class="p">,</span><span class="n">targets</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">labelset</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">labelset</span><span class="p">:</span>
                    <span class="n">edges</span><span class="p">[(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">label2vertex</span><span class="p">[</span><span class="n">source</span><span class="p">],</span><span class="n">label2vertex</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vertex2label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">graph</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span>

</div>
<div class="viewcode-block" id="availables_spatial_properties"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.availables_spatial_properties">[docs]</a><span class="k">def</span> <span class="nf">availables_spatial_properties</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return available properties to be computed by &#39;temporal_graph_from_image&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="s">&#39;boundingbox&#39;</span><span class="p">,</span> <span class="s">&#39;volume&#39;</span><span class="p">,</span> <span class="s">&#39;barycenter&#39;</span><span class="p">,</span> <span class="s">&#39;L1&#39;</span><span class="p">,</span> <span class="s">&#39;border&#39;</span><span class="p">,</span> <span class="s">&#39;inertia_axis&#39;</span><span class="p">,</span> <span class="s">&#39;wall_surface&#39;</span><span class="p">,</span> <span class="s">&#39;epidermis_surface&#39;</span><span class="p">,</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span><span class="p">,</span> <span class="s">&#39;wall_median&#39;</span><span class="p">,</span> <span class="s">&#39;all_walls_orientation&#39;</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature&#39;</span><span class="p">,</span> <span class="s">&#39;rank-2_projection_matrix&#39;</span><span class="p">,</span> <span class="s">&#39;reduced_inertia_axis&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="availables_temporal_properties"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.availables_temporal_properties">[docs]</a><span class="k">def</span> <span class="nf">availables_temporal_properties</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return available properties to be computed by &#39;temporal_graph_from_image&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="s">&#39;surfacic_3D_landmarks&#39;</span><span class="p">,</span> <span class="s">&#39;3D_landmarks&#39;</span><span class="p">,</span> <span class="s">&#39;division_wall&#39;</span><span class="p">,</span> <span class="s">&#39;division_wall_orientation&#39;</span><span class="p">,</span> <span class="s">&#39;fused_siblings_inertia_axis&#39;</span><span class="p">]</span>
    <span class="c">#~ return [&#39;surfacic_3D_landmarks&#39;, &#39;division_wall&#39;, &#39;division_wall_orientation&#39;, &#39;fused_siblings_inertia_axis&#39;]</span>
</div>
<div class="viewcode-block" id="availables_properties"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.availables_properties">[docs]</a><span class="k">def</span> <span class="nf">availables_properties</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return available properties to be computed by &#39;temporal_graph_from_image&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">availables_spatial_properties</span><span class="p">()</span><span class="o">+</span><span class="n">availables_temporal_properties</span><span class="p">())</span>

</div>
<div class="viewcode-block" id="check_properties"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.check_properties">[docs]</a><span class="k">def</span> <span class="nf">check_properties</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used to ensure &#39;spatio_temporal_properties&#39; coherence !</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="p">[</span><span class="n">spatio_temporal_properties</span><span class="p">]</span>

    <span class="k">if</span> <span class="s">&#39;surfacic_3D_landmarks&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">()</span> <span class="ow">and</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;projected_anticlinal_wall_median&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">()</span> <span class="ow">and</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;wall_median&#39;</span><span class="p">)</span> <span class="c"># will compute &#39;epidermis_wall_median&#39; and &#39;unlabelled_wall_median&#39; too !</span>
        <span class="k">if</span> <span class="s">&#39;L1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">()</span> <span class="ow">and</span> <span class="s">&#39;L1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;L1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;3D_landmarks&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">()</span> <span class="ow">and</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;wall_median&#39;</span><span class="p">)</span> <span class="c"># will compute &#39;epidermis_wall_median&#39; and &#39;unlabelled_wall_median&#39; too !</span>
        <span class="k">if</span> <span class="s">&#39;L1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">()</span> <span class="ow">and</span> <span class="s">&#39;L1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;L1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;division_wall_orientation&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="ow">or</span> <span class="s">&#39;projected_division_wall_orientation&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;division_wall&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">()</span> <span class="ow">and</span> <span class="s">&#39;division_wall&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;division_wall&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;rank-2_projection_matrix&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="ow">and</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
        <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;rank-2_projection_matrix&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="s">&#39;epidermis_local_principal_curvature&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
        <span class="n">index_radius</span> <span class="o">=</span> <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;epidermis_local_principal_curvature&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">spatio_temporal_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">]]</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index_radius</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">],</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">spatio_temporal_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">]</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index_radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="mi">70</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&#39;radius_local_principal_curvature_estimation&#39;</span><span class="p">,</span><span class="n">radius</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&#39;radius_2_compute&#39;</span><span class="p">,</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">existing_radius</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;radius_local_principal_curvature_estimation&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
            <span class="n">radius_2_compute</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">-</span> <span class="n">existing_radius</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">extend_graph_property</span><span class="p">(</span><span class="s">&#39;radius_local_principal_curvature_estimation&#39;</span><span class="p">,</span> <span class="n">radius_2_compute</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&#39;radius_2_compute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius_2_compute</span>

    <span class="k">print</span> <span class="s">&quot;Selected `spatio_temporal_propert{}`: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;ies&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Selected radius{} to compute: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;es&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius_2_compute</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="s">&quot;&quot;</span><span class="p">,</span><span class="n">radius_2_compute</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">spatio_temporal_properties</span>

</div>
<span class="k">def</span> <span class="nf">_spatial_properties_from_images</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add properties from a `SpatialImageAnalysis` class object (representing a segmented image) to a TemporalPropertyGraph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">TemporalPropertyGraph</span><span class="p">)</span>
    <span class="n">neighborhood_dict</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span>
    <span class="n">available_properties</span> <span class="o">=</span> <span class="n">availables_spatial_properties</span><span class="p">()</span>
    <span class="c">#~ properties = [ppt for ppt in spatio_temporal_properties if isinstance(ppt,str)] # we want to compare str types, no extra args passed</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="n">ppt</span> <span class="k">for</span> <span class="n">ppt</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">]</span> <span class="c"># we want to compare str types, no extra args passed</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">available_properties</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
        <span class="c"># -- Loop over all time points to compute required properties:</span>
        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s"># - Analysing image #{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
            <span class="c"># - Define SpatialImage type `labels` to compute for:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vids</span><span class="p">])</span>
            <span class="n">labelset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">neighborhood_dict</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span>
            <span class="c"># - Retrieve `min_contact_surface`</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;min_contact_surface&#39;</span><span class="p">)</span>
                <span class="n">real_surface</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;real_min_contact_surface&#39;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_contact_surface</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_contact_surface</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">real_surface</span> <span class="o">=</span> <span class="n">property_as_real</span>

            <span class="c"># -- Saving images voxelsizes (useful for converting voxel units in real-world units)</span>
            <span class="n">extend_graph_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&quot;images_voxelsize&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">tp</span><span class="p">:</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">})</span>

            <span class="c"># -- We want to keep the unit system of each variable</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&quot;units&quot;</span><span class="p">,</span><span class="nb">dict</span><span class="p">())</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>

            <span class="n">boundingboxes</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;boundingbox&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Extracting boundingbox...&#39;</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;boundingbox&#39;</span><span class="p">,</span> <span class="n">boundingboxes</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;boundingbox&quot;</span><span class="p">:</span><span class="s">&#39;voxels&#39;</span><span class="p">}</span> <span class="p">)</span>


            <span class="k">if</span> <span class="s">&#39;volume&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="ow">and</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">is3D</span><span class="p">():</span>
                <span class="k">print</span> <span class="s">&#39;- Computing volume property...&#39;</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;volume&#39;</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">),</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;volume&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb3</span><span class="s">&#39;</span><span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>


            <span class="n">barycenters_voxel</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;barycenter&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing barycenter property...&#39;</span>
                <span class="n">barycenters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">l</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">barycenters_voxel</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;barycenter&#39;</span><span class="p">,</span> <span class="n">barycenters</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;barycenter_voxel&#39;</span><span class="p">,</span> <span class="n">barycenters_voxel</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;barycenter&quot;</span><span class="p">:</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m&#39;</span><span class="p">}</span> <span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;barycenter_voxel&quot;</span><span class="p">:</span><span class="s">&#39;voxels&#39;</span><span class="p">}</span> <span class="p">)</span>


            <span class="k">if</span> <span class="s">&#39;L1&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Generating the list of cells belonging to the first layer...&#39;</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">background_neighbors</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">background_neighbors</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;L1&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span> <span class="ow">in</span> <span class="n">background_neighbors</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]),</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>


            <span class="k">if</span> <span class="s">&#39;border&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Generating the list of cells at the margins of the stack...&#39;</span>
                <span class="n">border_cells</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">cells_in_image_margins</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">border_cells</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
                <span class="n">border_cells</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">border_cells</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;border&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span> <span class="ow">in</span> <span class="n">border_cells</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]),</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>

            <span class="c"># Testing purpose only (for now):</span>
            <span class="c">#~ if &#39;reduced_inertia_axis&#39; in spatio_temporal_properties :</span>
                <span class="c">#~ print &#39;Computing reduced_inertia_axis property...&#39;</span>
                <span class="c">#~ inertia_axis, inertia_values = SpI_Analysis[tp].reduced_inertia_axis(labels, barycenters_voxel)</span>
                <span class="c">#~ extend_vertex_property_from_dictionary(graph, &#39;reduced_inertia_axis&#39;, inertia_axis, time_point=tp)</span>
                <span class="c">#~ extend_vertex_property_from_dictionary(graph, &#39;reduced_inertia_values&#39;, inertia_values, time_point=tp)</span>

            <span class="k">if</span> <span class="s">&#39;inertia_axis&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing inertia_axis property...&#39;</span>
                <span class="n">inertia_axis</span><span class="p">,</span> <span class="n">inertia_values</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">inertia_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">barycenters_voxel</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;inertia_axis&#39;</span><span class="p">,</span> <span class="n">inertia_axis</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;inertia_values&#39;</span><span class="p">,</span> <span class="n">inertia_values</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="c">#~ print &quot;Searching normal axis to epidermis surface...&quot;</span>
                <span class="c">#~ surface_normal_axis = SpI_Analysis[tp].inertia_axis_normal_to_surface(labels, real=property_as_real, verbose=True)</span>
                <span class="c">#~ extend_vertex_property_from_dictionary(graph, &#39;normal_inertia_axis_to_surface&#39;, surface_normal_axis, time_point=tp)</span>

            <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;wall_surface&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">labels_w_undef_neigh</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">labels_w_undef_neigh</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="k">print</span> <span class="s">&#39;- Computing wall_surface property...&#39;</span>
                <span class="n">filtered_edges</span><span class="p">,</span> <span class="n">unlabelled_target</span><span class="p">,</span> <span class="n">unlabelled_wall_surfaces</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">source</span><span class="p">,</span><span class="n">targets</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">labelset</span> <span class="p">:</span>
                        <span class="n">filtered_edges</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">target</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span> <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">labelset</span> <span class="p">]</span>
                        <span class="n">unlabelled_target</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">target</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span> <span class="k">if</span> <span class="p">(</span><span class="n">source</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">+</span><span class="p">[</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">]])</span> <span class="p">]</span> <span class="c"># if target == background[tp] =&gt; epidermis wall !!</span>
                <span class="n">wall_surfaces</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">wall_surfaces</span><span class="p">(</span><span class="n">filtered_edges</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">)</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_surface&#39;</span><span class="p">,</span> <span class="n">wall_surfaces</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">labels_w_undef_neigh</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">unlabelled_target</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">k</span><span class="p">,[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">unlabelled_target</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">unlabelled_target</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">labels_w_undef_neigh</span> <span class="p">])</span> <span class="p">)</span>
                
                <span class="n">unlabelled_wall_surface</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">wall_surfaces</span><span class="p">({</span><span class="n">source</span><span class="p">:(</span><span class="n">unlabelled_target</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unlabelled_target</span><span class="p">[</span><span class="n">source</span><span class="p">],</span><span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">unlabelled_target</span><span class="p">[</span><span class="n">source</span><span class="p">]])},</span><span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">unlabelled_target</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_surface&#39;</span><span class="p">,</span> <span class="n">unlabelled_wall_surface</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;wall_surface&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s">&#39;</span> <span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;unlabelled_wall_surface&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s">&#39;</span><span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>


            <span class="k">if</span> <span class="s">&#39;epidermis_surface&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">background_neighbors</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">background_neighbors</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="k">print</span> <span class="s">&#39;- Computing epidermis_surface property...&#39;</span>
                <span class="k">def</span> <span class="nf">not_background</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">indices</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">]:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                        <span class="k">else</span> <span class="p">:</span> <span class="k">return</span> <span class="n">b</span>
                    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">]:</span> <span class="k">return</span> <span class="n">a</span>
                    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="n">epidermis_surfaces</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="n">background_neighbors</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">)</span>
                <span class="n">epidermis_surfaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">not_background</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">indices</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">epidermis_surfaces</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;epidermis_surface&#39;</span><span class="p">,</span> <span class="n">epidermis_surfaces</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;epidermis_surface&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s">&#39;</span> <span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>


            <span class="k">if</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing projected_anticlinal_wall_median property...&#39;</span>
                <span class="n">dict_anticlinal_wall_voxels</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">wall_voxels_per_cells_pairs</span><span class="p">(</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">layer1</span><span class="p">(),</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">only_epidermis</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">ignore_background</span> <span class="o">=</span> <span class="bp">True</span> <span class="p">)</span>
                <span class="n">wall_median</span> <span class="o">=</span> <span class="n">find_wall_median_voxel</span><span class="p">(</span><span class="n">dict_anticlinal_wall_voxels</span><span class="p">,</span> <span class="n">labels2exclude</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span><span class="p">,</span> <span class="n">wall_median</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;projected_anticlinal_wall_median&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m&#39;</span> <span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>


            <span class="k">if</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing wall_median property...&#39;</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">background_neighbors</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">background_neighbors</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="k">try</span><span class="p">:</span> <span class="n">labels_w_undef_neigh</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">labels_w_undef_neigh</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="k">try</span><span class="p">:</span> <span class="n">dict_wall_voxels</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;-- Extracting walls voxels...&quot;</span>
                    <span class="c"># -- We start by defining all (pairs of cells defining) walls we want to extract:</span>
                    <span class="n">cell_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([(</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">nei</span><span class="p">)</span> <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">background_neighbors</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nei</span><span class="p">)</span> <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">labels_w_undef_neigh</span><span class="p">]</span> \
                            <span class="o">+</span> <span class="p">[(</span><span class="nb">min</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]))</span> <span class="k">for</span> <span class="n">label_1</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="p">[</span><span class="n">label_1</span><span class="p">]])</span>
                    <span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">wall_voxels_between_two_cells</span>
                    <span class="n">dict_wall_voxels</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">nb_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_pairs</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_pairs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">nb_pairs</span><span class="o">&gt;=</span><span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">nb_pairs</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
                        <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">sort_boundingbox</span><span class="p">(</span><span class="n">boundingboxes</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">label_2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">dict_wall_voxels</span><span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">])]</span> <span class="o">=</span> <span class="n">wall_voxels_between_two_cells</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">,</span> <span class="n">boundingboxes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

                <span class="k">print</span> <span class="s">&quot;-- Searching for the median voxel of each wall and computing the &#39;wall flattening&#39; (rank-2 projection) matrix...&quot;</span> 
                <span class="n">dict_wall_median_voxel</span> <span class="o">=</span> <span class="n">find_wall_median_voxel</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">,</span> <span class="n">labels2exclude</span> <span class="o">=</span> <span class="p">[])</span>
                <span class="n">wall_median</span><span class="p">,</span> <span class="n">unlabelled_wall_median</span><span class="p">,</span> <span class="n">epidermis_wall_median</span> <span class="o">=</span> <span class="p">{},{},{}</span>
                <span class="n">epidermis_proj_matrix</span><span class="p">,</span> <span class="n">proj_matrix</span> <span class="o">=</span> <span class="p">{},{}</span>
                <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_wall_voxels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys when creating `dict_wall_voxels`</span>
                        <span class="n">unlabelled_wall_median</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_wall_median_voxel</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys when creating `dict_wall_voxels`</span>
                        <span class="n">epidermis_wall_median</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_wall_median_voxel</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">epidermis_proj_matrix</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">projection_matrix</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dict_wall_median_voxel</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">proj_matrix</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">projection_matrix</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_median&#39;</span><span class="p">,</span> <span class="n">wall_median</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_rank-2_projection_matrix&#39;</span><span class="p">,</span> <span class="n">proj_matrix</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_median&#39;</span><span class="p">,</span> <span class="n">epidermis_wall_median</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_rank-2_projection_matrix&#39;</span><span class="p">,</span> <span class="n">epidermis_proj_matrix</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_median&#39;</span><span class="p">,</span> <span class="n">unlabelled_wall_median</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;wall_median&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m&#39;</span> <span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;epidermis_wall_median&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m&#39;</span> <span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">_graph_property</span><span class="p">[</span><span class="s">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;unlabelled_wall_median&quot;</span><span class="p">:(</span><span class="s">u&#39;</span><span class="se">\xb5</span><span class="s">m&#39;</span> <span class="k">if</span> <span class="n">property_as_real</span> <span class="k">else</span> <span class="s">&#39;voxels&#39;</span><span class="p">)}</span> <span class="p">)</span>

            <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>

            <span class="c"># -- The following property will not be computed if &#39;wall_median&#39; property is also asked (handled by `check_properties`)</span>
            <span class="k">if</span> <span class="s">&#39;rank-2_projection_matrix&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing projection_matrix property...&#39;</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">background_neighbors</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">background_neighbors</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="k">try</span><span class="p">:</span> <span class="n">labels_w_undef_neigh</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">labels_w_undef_neigh</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="k">try</span><span class="p">:</span> <span class="n">dict_wall_voxels</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;-- Extracting walls voxels...&quot;</span>
                    <span class="c"># -- We start by creating all pairs of cells defining a wall we want to extract:</span>
                    <span class="n">cell_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([(</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">nei</span><span class="p">)</span> <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">background_neighbors</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nei</span><span class="p">)</span> <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">labels_w_undef_neigh</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="nb">min</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]))</span> <span class="k">for</span> <span class="n">label_1</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="p">[</span><span class="n">label_1</span><span class="p">]])</span>
                    <span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">wall_voxels_between_two_cells</span>
                    <span class="n">dict_wall_voxels</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">nb_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_pairs</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_pairs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">nb_pairs</span><span class="o">&gt;=</span><span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">nb_pairs</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
                        <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">sort_boundingbox</span><span class="p">(</span><span class="n">boundingboxes</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                        <span class="n">dict_wall_voxels</span><span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">])]</span> <span class="o">=</span> <span class="n">wall_voxels_between_two_cells</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">,</span> <span class="n">boundingboxes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    <span class="k">print</span> <span class="s">&quot;-- Computing the rank-2 projection matrix of the wall voxels set...&quot;</span> 
                
                <span class="n">epidermis_proj_matrix</span><span class="p">,</span> <span class="n">proj_matrix</span> <span class="o">=</span> <span class="p">{},{}</span>
                <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_wall_voxels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys when creating `dict_wall_voxels`</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys when creating `dict_wall_voxels`</span>
                        <span class="n">epidermis_proj_matrix</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">projection_matrix</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">proj_matrix</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">projection_matrix</span><span class="p">(</span><span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_rank-2_projection_matrix&#39;</span><span class="p">,</span> <span class="n">proj_matrix</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_rank-2_projection_matrix&#39;</span><span class="p">,</span> <span class="n">epidermis_proj_matrix</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>


            <span class="k">if</span> <span class="s">&#39;all_walls_orientation&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing wall_orientation property...&#39;</span>
                <span class="c"># -- First we have to extract the voxels defining the frontier between two objects:</span>
                <span class="c"># - Extract wall_orientation property for &#39;unlabelled&#39; and &#39;epidermis&#39; walls as well:</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">background_neighbors</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">background_neighbors</span> <span class="o">=</span> <span class="n">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">],</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span> 
                <span class="k">try</span><span class="p">:</span> <span class="n">dict_wall_voxels</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">dict_wall_voxels</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">wall_voxels_per_cells_pairs</span><span class="p">(</span><span class="n">labels</span><span class="o">+</span><span class="p">[</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">]],</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">]:</span><span class="nb">list</span><span class="p">(</span><span class="n">background_neighbors</span><span class="p">)}),</span> <span class="n">ignore_background</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>

                <span class="n">pc_values</span><span class="p">,</span> <span class="n">pc_normal</span><span class="p">,</span> <span class="n">pc_directions</span><span class="p">,</span> <span class="n">pc_origin</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">wall_orientation</span><span class="p">(</span> <span class="n">dict_wall_voxels</span><span class="p">,</span> <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plane_projection</span> <span class="o">=</span> <span class="bp">False</span> <span class="p">)</span>
                <span class="c"># -- Now we can compute the orientation of the frontier between two objects:</span>
                <span class="n">edge_pc_values</span><span class="p">,</span> <span class="n">edge_pc_normal</span><span class="p">,</span> <span class="n">edge_pc_directions</span><span class="p">,</span> <span class="n">edge_pc_origin</span> <span class="o">=</span> <span class="p">{},{},{},{}</span>
                <span class="n">vertex_pc_values</span><span class="p">,</span> <span class="n">vertex_pc_normal</span><span class="p">,</span> <span class="n">vertex_pc_directions</span><span class="p">,</span> <span class="n">vertex_pc_origin</span> <span class="o">=</span> <span class="p">{},{},{},{}</span>
                <span class="n">epidermis_pc_values</span><span class="p">,</span> <span class="n">epidermis_pc_normal</span><span class="p">,</span> <span class="n">epidermis_pc_directions</span><span class="p">,</span> <span class="n">epidermis_pc_origin</span> <span class="o">=</span> <span class="p">{},{},{},{}</span>
                <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_wall_voxels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">label_2</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
                        <span class="n">edge_pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">edge_pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">edge_pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">edge_pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys returned by `wall_voxels_per_cells_pairs`</span>
                        <span class="n">vertex_pc_values</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">vertex_pc_normal</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">vertex_pc_directions</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">vertex_pc_origin</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys returned by `wall_voxels_per_cells_pairs`</span>
                        <span class="n">epidermis_pc_values</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">epidermis_pc_normal</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">epidermis_pc_directions</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">epidermis_pc_origin</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="c"># -- Now we save values:</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_values&#39;</span><span class="p">,</span> <span class="n">edge_pc_values</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_normal&#39;</span><span class="p">,</span> <span class="n">edge_pc_normal</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_directions&#39;</span><span class="p">,</span> <span class="n">edge_pc_directions</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                    <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">edge_pc_origin</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vertex_pc_values</span> <span class="o">!=</span> <span class="p">{}:</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_values&#39;</span><span class="p">,</span> <span class="n">vertex_pc_values</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_normal&#39;</span><span class="p">,</span> <span class="n">vertex_pc_normal</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_directions&#39;</span><span class="p">,</span> <span class="n">vertex_pc_directions</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                        <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">vertex_pc_origin</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">epidermis_pc_values</span> <span class="o">!=</span> <span class="p">{}:</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_values&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_values</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_normal&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_normal</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_directions&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_directions</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                        <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_origin</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>


            <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;epidermis_local_principal_curvature&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">radius</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;radius_2_compute&#39;</span><span class="p">):</span>
                    <span class="k">print</span> <span class="s">&#39;- Computing local_principal_curvature property with radius = {}voxels...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
                    <span class="k">print</span> <span class="s">u&quot;This represent a local curvature estimation area of {}</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">radius</span><span class="o">*</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">radius</span><span class="o">*</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">_voxelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">principal_curvatures_normal</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">principal_curvatures_directions</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
                    <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">compute_principal_curvatures</span><span class="p">(</span><span class="n">vids</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_values_r&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_normal_r&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">principal_curvatures_normal</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_directions_r&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">principal_curvatures_directions</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                    <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">principal_curvatures_origin</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                <span class="c">#embed()</span>

            <span class="c"># - We want `dict_wall_voxels`, `background_neighbors` and `labels_w_undef_neigh` to be computed again at each `time_point`:</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="n">dict_wall_voxels</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="n">background_neighbors</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="n">labels_w_undef_neigh</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>

        <span class="c"># - We want to compute the &#39;epidermis_local_principal_curvature&#39; for all time points:</span>
        <span class="k">try</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">remove_graph_property</span><span class="p">(</span><span class="s">&#39;radius_2_compute&#39;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
    
    <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>


<span class="k">def</span> <span class="nf">_temporal_properties_from_images</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add properties from a `SpatialImageAnalysis` class object (representing a segmented image) to a TemporalPropertyGraph.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `graph` (TPG)</span>
<span class="sd">     - `SpI_Analysis` (AbstractSpatialImageAnalysis) - Spatial analysis of an image.</span>
<span class="sd">     - `labels` (list) - list of labels to be found in the image.</span>
<span class="sd">     - `label2vertex`</span>
<span class="sd">     - `background` (int) - label representing background.</span>
<span class="sd">     - `spatio_temporal_properties` (list) - the list of name of properties to create. It should be in spatio_temporal_properties.</span>
<span class="sd">     - `property_as_real` (bool) - If property_as_real = True, property is in real-world units else in voxels.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;Starting computation of temporal properties&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;min_contact_surface&#39;</span><span class="p">)</span>
        <span class="n">real_surface</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;real_min_contact_surface&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_contact_surface</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_contact_surface</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">real_surface</span> <span class="o">=</span> <span class="n">property_as_real</span>
    
    <span class="c"># - Declare available properties and start computation if asked:</span>
    <span class="n">available_properties</span> <span class="o">=</span> <span class="n">availables_temporal_properties</span><span class="p">()</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="n">ppt</span> <span class="k">for</span> <span class="n">ppt</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ppt</span><span class="p">,</span><span class="nb">str</span><span class="p">)]</span> <span class="c"># we want to compare str types, no extra args passed</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">available_properties</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>

        <span class="n">fused_image_analysis</span><span class="p">,</span> <span class="n">neighborhood</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s">&#39;surfacic_3D_landmarks&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;- Computing surfacic_3D_landmarks...&quot;</span>
            <span class="c"># -- Assert we have the data we need to create the landmarks:</span>
            <span class="k">assert</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property_names</span><span class="p">()</span>

            <span class="c"># -- First we need to extract the medians of &#39;anticlinal walls&#39; at the surface for the daughters fused images:</span>
            <span class="c"># Try to use &#39;fused_image_analysis&#39; dict else compute it:</span>
            <span class="k">if</span> <span class="n">fused_image_analysis</span> <span class="o">==</span> <span class="p">{}</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">fused_image_analysis</span><span class="p">)</span> <span class="o">!=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="p">:</span>
                <span class="n">fused_image_analysis</span> <span class="o">=</span> <span class="n">create_fused_image_analysis</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">)</span>

            <span class="n">fused_anticlinal_wall_median</span><span class="p">,</span> <span class="n">fused_epidermis_wall_median</span><span class="p">,</span> <span class="n">epidermis_proj_matrix</span><span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">tp_2fuse</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ref_tp</span> <span class="o">=</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">print</span> <span class="s">&quot;-- Extract the surfacic wall medians for &#39;fused sibling&#39; cells in image t{} (ref. t{})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tp_2fuse</span><span class="p">,</span> <span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">ref_vids</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">ref_tp</span><span class="p">,</span> <span class="n">as_parent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vids</span><span class="p">]</span>
                <span class="n">ref_SpI_ids</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ref_vids</span><span class="p">)</span>
                <span class="c"># - Extracting neighborhood info:</span>
                <span class="n">fused_neighborhood</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">,</span> <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="n">min_contact_surface</span><span class="p">)</span>
                <span class="c"># - Computing voxels position of &#39;anticlinal walls&#39; at the surface:</span>
                <span class="n">fused_dict_anticlinal_wall_voxels</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">wall_voxels_per_cells_pairs</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">,</span> <span class="n">fused_neighborhood</span><span class="p">,</span> <span class="n">only_epidermis</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">ignore_background</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
                <span class="c"># - Finally compute the position of the median for each groups of voxels:</span>
                <span class="n">fused_anticlinal_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_wall_median_voxel</span><span class="p">(</span><span class="n">fused_dict_anticlinal_wall_voxels</span><span class="p">,</span> <span class="n">labels2exclude</span> <span class="o">=</span> <span class="p">[])</span>
                <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">fused_anticlinal_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys returned by `wall_voxels_per_cells_pairs`</span>
                        <span class="n">fused_epidermis_wall_median</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fused_anticlinal_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                        <span class="n">fused_anticlinal_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">((</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">))</span>
                        <span class="n">epidermis_proj_matrix</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">projection_matrix</span><span class="p">(</span><span class="n">fused_dict_anticlinal_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_epidermis_wall_median&#39;</span><span class="p">,</span> <span class="n">fused_epidermis_wall_median</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_epidermis_rank-2_projection_matrix&#39;</span><span class="p">,</span> <span class="n">epidermis_proj_matrix</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="n">ref_tp</span><span class="p">)</span>

            <span class="c"># -- Now we can proceed to the landmarks association:</span>
            <span class="k">for</span> <span class="n">tp_2fuse</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ref_tp</span> <span class="o">=</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">print</span> <span class="s">&quot;-- Surfacic 3D landmarks association between t{} and t{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_tp</span><span class="p">,</span> <span class="n">tp_2fuse</span><span class="p">)</span>
                <span class="c"># - Translating &#39;projected_anticlinal_wall_median&#39; in `graph.edge_property()` with pair of labels as keys:</span>
                <span class="n">edge2labelpair_m</span> <span class="o">=</span> <span class="n">edge2labelpair_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">wall_median</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">edge2labelpair_m</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;projected_anticlinal_wall_median&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">edge2labelpair_m</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">eid</span><span class="p">)])</span>
                <span class="c"># - Starting the anticlinal wall landmarks association:</span>
                <span class="n">asso</span><span class="p">,</span> <span class="n">no_asso_found</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wall_median</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fused_anticlinal_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">asso</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">wall_median</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">fused_anticlinal_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">no_asso_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

                <span class="c"># - Saving detected landmarks association:</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;surfacic_3D_landmarks&#39;</span><span class="p">,</span> <span class="n">asso</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>

                <span class="c"># - Displaying informations about how good this landmarks association step went :</span>
                <span class="k">print</span> <span class="s">&quot;-- Found {} associations over {} ({}%)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">asso</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">wall_median</span><span class="p">),</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">asso</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">wall_median</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">new_contact_from_fusing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fused_anticlinal_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">asso</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_contact_from_fusing</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
                    <span class="k">print</span> <span class="s">&quot;-- New contacts found after siblings fusion :&quot;</span>
                    <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">new_contact_from_fusing</span><span class="p">:</span>
                        <span class="n">s_init</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">ref_tp</span><span class="p">]</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                        <span class="n">s_sib_fused</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                        <span class="k">print</span> <span class="s">u&quot;--- between {} &amp; {} -&gt; Area(t_n)={}</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s">, while Area(t_n-1)={}</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s"> ({})&quot;</span>\
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">s_sib_fused</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">s_init</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s">&quot;undefined&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">s_init</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="s">&quot;filtered&quot;</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;3D_landmarks&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Work in progress ...</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">print</span> <span class="s">&quot;- Computing 3D_landmarks...&quot;</span>
            <span class="c"># -- Assert we have the data we need to create the landmarks:</span>
            <span class="k">assert</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property_names</span><span class="p">()</span>
            <span class="k">assert</span> <span class="s">&#39;unlabelled_wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property_names</span><span class="p">()</span>
            <span class="k">assert</span> <span class="s">&#39;epidermis_wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property_names</span><span class="p">()</span>

            <span class="c"># -- First we need to extract the medians of each cell wall for the sibling-fused images:</span>
            <span class="c"># Try to use &#39;fused_image_analysis&#39; dict else compute it:</span>
            <span class="k">if</span> <span class="n">fused_image_analysis</span> <span class="o">==</span> <span class="p">{}</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">fused_image_analysis</span><span class="p">)</span> <span class="o">!=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="p">:</span>
                <span class="n">fused_image_analysis</span> <span class="o">=</span> <span class="n">create_fused_image_analysis</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">)</span>

            <span class="n">fused_wall_median</span><span class="p">,</span> <span class="n">fused_unlabelled_wall_median</span><span class="p">,</span> <span class="n">fused_epidermis_wall_median</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">tp_2fuse</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ref_tp</span> <span class="o">=</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">print</span> <span class="s">&quot;-- Extract the wall median for &#39;fused sibling&#39; cells in image t{} (ref. t{})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tp_2fuse</span><span class="p">,</span> <span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">ref_vids</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">ref_tp</span><span class="p">,</span> <span class="n">as_parent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vids</span><span class="p">]</span>
                <span class="n">ref_SpI_ids</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ref_vids</span><span class="p">)</span>
                <span class="c"># - Extracting neighborhood info:</span>
                <span class="n">fused_neighborhood</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">,</span> <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="n">min_contact_surface</span><span class="p">)</span>
                <span class="c"># - Extracting &quot;background neighborhood&quot; info:</span>
                <span class="n">fused_background_neighbors</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">background</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fused_background_neighbors</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">fused_background_neighbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fused_background_neighbors</span><span class="p">[</span><span class="n">background</span><span class="p">[</span><span class="n">tp</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fused_background_neighbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fused_background_neighbors</span><span class="p">)</span>
                <span class="n">fused_background_neighbors</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">))</span>
                <span class="c"># - Extracting &quot;undefined neighborhood&quot; info:</span>
                <span class="n">fused_labels_w_undef_neigh</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fused_labels_w_undef_neigh</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">fused_labels_w_undef_neigh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fused_labels_w_undef_neigh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fused_labels_w_undef_neigh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fused_labels_w_undef_neigh</span><span class="p">)</span>
                <span class="n">fused_labels_w_undef_neigh</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">))</span>

                <span class="c"># - We start by creating all pairs of cells defining a wall we want to extract:</span>
                <span class="n">fused_cell_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([(</span><span class="n">background</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">nei</span><span class="p">)</span> <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">fused_background_neighbors</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nei</span><span class="p">)</span> <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">fused_labels_w_undef_neigh</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="nb">min</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]))</span> <span class="k">for</span> <span class="n">label_1</span> <span class="ow">in</span> <span class="n">fused_neighborhood</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">fused_neighborhood</span><span class="p">[</span><span class="n">label_1</span><span class="p">]])</span>
                <span class="n">fused_boundingboxes</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
                <span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">wall_voxels_between_two_cells</span>
                <span class="n">fused_dict_wall_voxels</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">nb_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fused_cell_pairs</span><span class="p">);</span> <span class="n">percent</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fused_cell_pairs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">nb_pairs</span><span class="o">&gt;=</span><span class="n">percent</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;{}%...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">percent</span><span class="p">),;</span> <span class="n">percent</span> <span class="o">+=</span> <span class="mi">10</span>
                    <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">nb_pairs</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;100%&quot;</span>
                    <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">sort_boundingbox</span><span class="p">(</span><span class="n">fused_boundingboxes</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                    <span class="n">fused_dict_wall_voxels</span><span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">])]</span> <span class="o">=</span> <span class="n">wall_voxels_between_two_cells</span><span class="p">(</span><span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">,</span> <span class="n">fused_boundingboxes</span><span class="p">)</span>

                <span class="k">print</span> <span class="s">&quot;-- Searching the median voxel of each cell wall...&quot;</span> 
                <span class="n">fused_wall_median_voxel</span> <span class="o">=</span> <span class="n">find_wall_median_voxel</span><span class="p">(</span><span class="n">fused_dict_wall_voxels</span><span class="p">,</span> <span class="n">labels2exclude</span> <span class="o">=</span> <span class="p">[])</span>
                <span class="n">fused_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">fused_unlabelled_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">fused_epidermis_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},{},{}</span>
                <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">fused_wall_median_voxel</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys when creating `dict_wall_voxels`</span>
                        <span class="n">fused_unlabelled_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fused_wall_median_voxel</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys when creating `dict_wall_voxels`</span>
                        <span class="n">fused_epidermis_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fused_wall_median_voxel</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fused_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fused_wall_median_voxel</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>

                <span class="c"># - We save the &#39;epidermis&#39; and &#39;unlabelled&#39; wall medians for the fused siblings (on the vertex at ref_tp):</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_epidermis_wall_median&#39;</span><span class="p">,</span> <span class="n">fused_epidermis_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_unlabelled_wall_median&#39;</span><span class="p">,</span> <span class="n">fused_unlabelled_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>
                <span class="c"># - We save the wall medians for the fused siblings (on the corresponding edge @ ref_tp):</span>
                <span class="n">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_wall_median&#39;</span><span class="p">,</span> <span class="n">fused_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">],</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>

            <span class="c"># -- Now we can proceed to the landmarks association:</span>
            <span class="k">for</span> <span class="n">tp_2fuse</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ref_tp</span> <span class="o">=</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">print</span> <span class="s">&quot;-- 3D landmarks association between t{} and &#39;sibling-fused&#39; t{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_tp</span><span class="p">,</span> <span class="n">tp_2fuse</span><span class="p">)</span>
                <span class="c"># -- Pairing t_n and t_n+1 &#39;wall_median&#39; as landmarks:</span>
                <span class="c"># - the following dict are {cid:coordinates} (not vertex ids!):</span>
                <span class="c">#wall_median, unlabelled_wall_median, epidermis_wall_median, fused_wall_median, fused_unlabelled_wall_median, fused_epidermis_wall_median</span>
                <span class="n">edge2labelpair_m</span> <span class="o">=</span> <span class="n">edge2labelpair_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">wall_median</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">edge2labelpair_m</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_median&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">edge2labelpair_m</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">eid</span><span class="p">)])</span>
                <span class="n">ref_vids</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">ref_tp</span><span class="p">,</span> <span class="n">as_parent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vids</span><span class="p">]</span>
                <span class="n">vid2cid</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;old_label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ref_vids</span><span class="p">])</span>
                <span class="n">unlabelled_wall_median</span> <span class="o">=</span>  <span class="nb">dict</span><span class="p">([(</span><span class="n">vid2cid</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;unlabelled_wall_median&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ref_vids</span><span class="p">])</span>
                <span class="n">epidermis_wall_median</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">vid2cid</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;epidermis_wall_median&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ref_vids</span><span class="p">])</span>
                <span class="c"># - Starting the landmarks association:</span>
                <span class="n">ldmk</span><span class="p">,</span> <span class="n">nb_asso</span><span class="p">,</span> <span class="n">nb_asso_unlabelled</span><span class="p">,</span> <span class="n">nb_asso_epidermis</span> <span class="o">=</span> <span class="p">{},</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="n">no_asso</span><span class="p">,</span> <span class="n">no_asso_unlabelled</span><span class="p">,</span> <span class="n">no_asso_epidermis</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="c"># - Pairing t_n and t_n+1 &#39;wall_median&#39; as landmarks:</span>
                <span class="k">for</span> <span class="n">labelpair</span> <span class="ow">in</span> <span class="n">wall_median</span><span class="p">:</span>
                    <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">labelpair</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ldmk</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_1</span><span class="p">)):</span>
                        <span class="n">ldmk</span><span class="p">[</span><span class="n">label_1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ldmk</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">label_2</span><span class="p">)):</span>
                        <span class="n">ldmk</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ldmk</span><span class="p">[</span><span class="n">label_1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">wall_median</span><span class="p">[</span><span class="n">labelpair</span><span class="p">],</span> <span class="n">fused_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][</span><span class="n">labelpair</span><span class="p">]])</span>
                        <span class="n">ldmk</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">wall_median</span><span class="p">[</span><span class="n">labelpair</span><span class="p">],</span> <span class="n">fused_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][</span><span class="n">labelpair</span><span class="p">]])</span>
                        <span class="n">nb_asso</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">no_asso</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelpair</span><span class="p">)</span>
                <span class="c"># - Pairing t_n and t_n+1 &#39;unlabelled_wall_median&#39; as landmarks:</span>
                <span class="k">for</span> <span class="n">label_1</span> <span class="ow">in</span> <span class="n">unlabelled_wall_median</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="c"># will fail if ldmk does not received any &#39;wall_median&#39; in the previous loop, but we do not want to rely only on &quot;unlabelled&quot; and &quot;epidermis&quot; landmarks!</span>
                        <span class="n">ldmk</span><span class="p">[</span><span class="n">label_1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">unlabelled_wall_median</span><span class="p">[</span><span class="n">label_1</span><span class="p">],</span> <span class="n">fused_unlabelled_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][</span><span class="n">label_1</span><span class="p">]])</span> 
                        <span class="n">nb_asso_unlabelled</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">no_asso_unlabelled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label_1</span><span class="p">)</span>
                <span class="c"># - Pairing t_n and t_n+1 &#39;epidermis_wall_median&#39; as landmarks:</span>
                <span class="k">for</span> <span class="n">label_1</span> <span class="ow">in</span> <span class="n">epidermis_wall_median</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ldmk</span><span class="p">[</span><span class="n">label_1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">epidermis_wall_median</span><span class="p">[</span><span class="n">label_1</span><span class="p">],</span> <span class="n">fused_epidermis_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">][</span><span class="n">label_1</span><span class="p">]])</span>
                        <span class="n">nb_asso_epidermis</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">no_asso_epidermis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label_1</span><span class="p">)</span>
                <span class="c"># - Saving detected landmarks association:</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;3D_landmarks&#39;</span><span class="p">,</span> <span class="n">ldmk</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>
                <span class="c"># - Displaying informations about how good this landmarks association step went :</span>
                <span class="n">N_asso2found</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall_median</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">unlabelled_wall_median</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">epidermis_wall_median</span><span class="p">)</span>
                <span class="n">N_asso_found</span> <span class="o">=</span> <span class="n">nb_asso</span><span class="o">+</span><span class="n">nb_asso_unlabelled</span><span class="o">+</span><span class="n">nb_asso_epidermis</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall_median</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;-- Found {} associations over {} ({}%) for &#39;wall_median&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_asso</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall_median</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_asso</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">wall_median</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unlabelled_wall_median</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;-- Found {} associations over {} ({}%) for &#39;unlabelled_wall_median&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_asso_unlabelled</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">unlabelled_wall_median</span><span class="p">),</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_asso_unlabelled</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">unlabelled_wall_median</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epidermis_wall_median</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;-- Found {} associations over {} ({}%) for &#39;epidermis_wall_median&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_asso_epidermis</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">epidermis_wall_median</span><span class="p">),</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_asso_epidermis</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">epidermis_wall_median</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">N_asso_found</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;-- Overall association rate: {}</span><span class="si">% o</span><span class="s">f potential landmarks...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">N_asso_found</span><span class="p">)</span><span class="o">/</span><span class="n">N_asso2found</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

                <span class="c"># -- Keeping an eye on topological &quot;errors&quot; occuring because of the two &quot;independant&quot; segmentations:</span>
                <span class="n">labelpair_wall_median</span> <span class="o">=</span> <span class="n">wall_median</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">labelpair_fused_wall_median</span> <span class="o">=</span> <span class="n">fused_wall_median</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">new_contact_from_fusing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labelpair_fused_wall_median</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">labelpair_wall_median</span><span class="p">)</span>
                <span class="c">#~ labelpair_unlabelled_wall_median = [(0,k) for k in unlabelled_wall_median.keys()]</span>
                <span class="c">#~ labelpair_fused_unlabelled_wall_median = [(0,k) for k in fused_unlabelled_wall_median[tp_2fuse].keys()]</span>
                <span class="c">#~ labelpair_epidermis_wall_median = [(1,k) for k in epidermis_wall_median.keys()]</span>
                <span class="c">#~ labelpair_fused_epidermis_wall_median = [(1,k) for k in fused_epidermis_wall_median[tp_2fuse].keys()]</span>
                <span class="c">#~ new_contact_from_fusing = set(labelpair_fused_wall_median)-set(labelpair_wall_median) \</span>
                                        <span class="c">#~ | set(labelpair_fused_unlabelled_wall_median)-set(labelpair_unlabelled_wall_median) \</span>
                                        <span class="c">#~ | set(labelpair_fused_epidermis_wall_median)-set(labelpair_epidermis_wall_median)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_contact_from_fusing</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
                    <span class="k">print</span> <span class="s">&quot;-- New contacts found after siblings fusion :&quot;</span>
                    <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">new_contact_from_fusing</span><span class="p">:</span>
                        <span class="n">s_init</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">ref_tp</span><span class="p">]</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                        <span class="n">s_sib_fused</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">s_init</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">state</span> <span class="o">=</span> <span class="s">&quot;undefined&quot;</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">s_init</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;min_contact_surface&#39;</span><span class="p">))</span> <span class="p">:</span> <span class="n">state</span> <span class="o">=</span> <span class="s">&quot;????????&quot;</span>
                        <span class="k">else</span> <span class="p">:</span> <span class="n">state</span> <span class="o">=</span> <span class="s">&quot;filtered&quot;</span>
                        <span class="k">print</span> <span class="s">u&quot;--- between {} &amp; {} -&gt; Area(t_n)={}</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s">, while Area(t_n-1)={}</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s"> ({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>\
                         <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">s_sib_fused</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">s_init</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span>


        <span class="k">if</span> <span class="s">&#39;division_wall&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;- Detecting division_wall property...&#39;</span>
            <span class="n">div_walls</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">eid</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">sibling</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edge_vertices</span><span class="p">(</span><span class="n">eid</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_vertices</span><span class="p">(</span><span class="n">eid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">sibling</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edge_vertices</span><span class="p">(</span><span class="n">eid</span><span class="p">)[</span><span class="mi">1</span><span class="p">])])</span>
            <span class="n">add_edge_property_from_eid_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;division_wall&#39;</span><span class="p">,</span> <span class="n">div_walls</span><span class="p">)</span>

        <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;division_wall_orientation&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">wall_voxels_between_two_cells</span>
            <span class="n">pc_values</span><span class="p">,</span> <span class="n">pc_normal</span><span class="p">,</span> <span class="n">pc_directions</span><span class="p">,</span> <span class="n">pc_origin</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s">&#39;all_walls_orientation&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                <span class="k">print</span> <span class="s">&#39;- Retreiving division_wall_orientation property from previously computed all_walls_orientation property...&#39;</span>
                <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;division_wall&#39;</span><span class="p">):</span>
                    <span class="n">pc_values</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_principal_curvature_values&#39;</span><span class="p">)[</span><span class="n">eid</span><span class="p">]</span>
                    <span class="n">pc_normal</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_principal_curvature_normal&#39;</span><span class="p">)[</span><span class="n">eid</span><span class="p">]</span>
                    <span class="n">pc_directions</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_principal_curvature_directions&#39;</span><span class="p">)[</span><span class="n">eid</span><span class="p">]</span>
                    <span class="n">pc_origin</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_principal_curvature_origin&#39;</span><span class="p">)[</span><span class="n">eid</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing division_wall_orientation property...&#39;</span>
                <span class="n">div_wall_voxels</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;division_wall&#39;</span><span class="p">):</span>
                    <span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_vertices</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>
                    <span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">div_wall_voxels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">continue</span> <span class="c"># skip the rest of the loop</span>
                    <span class="n">tp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">)[</span><span class="n">vid_1</span><span class="p">]</span>
                    <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span><span class="p">])</span>
                    <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="o">=</span> <span class="n">sort_boundingbox</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]),</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)</span>
                    <span class="n">div_wall_voxels</span><span class="p">[(</span><span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">wall_voxels_between_two_cells</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">([</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">]))</span>

                    <span class="k">if</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">()</span> <span class="ow">and</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_median&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">eid</span><span class="p">):</span>
                        <span class="n">median</span> <span class="o">=</span> <span class="p">{(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">):</span><span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_median&#39;</span><span class="p">)[</span><span class="n">eid</span><span class="p">]}</span>
                        <span class="n">pc_values</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span> <span class="n">pc_normal</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span> <span class="n">pc_directions</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span> <span class="n">pc_origin</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">wall_orientation</span><span class="p">(</span> <span class="p">{(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">):</span><span class="n">div_wall_voxels</span><span class="p">[(</span><span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span><span class="p">)]},</span> <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plane_projection</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">dict_coord_points_ori</span> <span class="o">=</span> <span class="n">median</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pc_values</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span> <span class="n">pc_normal</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span> <span class="n">pc_directions</span><span class="p">[</span><span class="n">eid</span><span class="p">],</span> <span class="n">pc_origin</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span><span class="o">.</span><span class="n">wall_orientation</span><span class="p">(</span> <span class="p">{(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">):</span><span class="n">div_wall_voxels</span><span class="p">[(</span><span class="n">vid_1</span><span class="p">,</span> <span class="n">vid_2</span><span class="p">)]},</span> <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plane_projection</span> <span class="o">=</span> <span class="bp">False</span> <span class="p">)</span>

            <span class="n">add_edge_property_from_eid_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;division_wall_principal_curvature_values&#39;</span><span class="p">,</span> <span class="n">pc_values</span><span class="p">)</span>
            <span class="n">add_edge_property_from_eid_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;division_wall_principal_curvature_normal&#39;</span><span class="p">,</span> <span class="n">pc_normal</span><span class="p">)</span>
            <span class="n">add_edge_property_from_eid_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;division_wall_principal_curvature_directions&#39;</span><span class="p">,</span> <span class="n">pc_directions</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                <span class="n">add_edge_property_from_eid_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;division_wall_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">pc_origin</span><span class="p">)</span>


        <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;projected_division_wall_orientation&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="c"># NOT WORKING YET !!!!!!!</span>
            <span class="c"># Could do a rank-1 subspace projection of anticlinal wall voxels ?</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="s">&#39;fused_siblings_inertia_axis&#39;</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
            <span class="c"># Try to use &#39;fused_image_analysis&#39; dict else compute it:</span>
            <span class="k">if</span> <span class="n">fused_image_analysis</span> <span class="o">==</span> <span class="p">{}</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">fused_image_analysis</span><span class="p">)</span> <span class="o">!=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;- Computing siblings fused images...&#39;</span>
                <span class="n">fused_image_analysis</span> <span class="o">=</span> <span class="n">create_fused_image_analysis</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">SpI_Analysis</span><span class="p">)</span>

            <span class="k">print</span> <span class="s">&#39;- Computing fused_siblings_inertia_axis property...&#39;</span>
            <span class="k">for</span> <span class="n">tp_2fuse</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">graph</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">&quot;-- Creating siblings fused SpatialImageAnalysis #{}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tp_2fuse</span><span class="p">)</span>
                <span class="n">ref_tp</span> <span class="o">=</span> <span class="n">tp_2fuse</span><span class="o">-</span><span class="mi">1</span>
                <span class="c">#~ ref_SpI_ids = fused_image_analysis[tp_2fuse].labels()</span>
                <span class="n">ref_SpI_ids</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">ref_tp</span><span class="p">,</span> <span class="n">as_parent</span><span class="o">=</span><span class="bp">True</span><span class="p">)])</span>
                <span class="k">print</span> <span class="s">&quot;-- Computing fused_siblings_inertia_axis property...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tp_2fuse</span><span class="p">)</span>
                <span class="n">fused_bary_vox</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
                <span class="n">inertia_axis</span><span class="p">,</span> <span class="n">inertia_values</span> <span class="o">=</span> <span class="n">fused_image_analysis</span><span class="p">[</span><span class="n">tp_2fuse</span><span class="p">]</span><span class="o">.</span><span class="n">inertia_axis</span><span class="p">(</span><span class="n">ref_SpI_ids</span><span class="p">,</span> <span class="n">fused_bary_vox</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_barycenter_voxel&#39;</span><span class="p">,</span> <span class="n">fused_bary_vox</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_inertia_axis&#39;</span><span class="p">,</span> <span class="n">inertia_axis</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>
                <span class="n">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;fused_siblings_inertia_values&#39;</span><span class="p">,</span> <span class="n">inertia_values</span><span class="p">,</span> <span class="n">time_point</span><span class="o">=</span><span class="n">ref_tp</span><span class="p">)</span>


    <span class="n">tpgfi_tracker_save</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>

<div class="viewcode-block" id="resume_tpgfi_feature_extraxtion"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.resume_tpgfi_feature_extraxtion">[docs]</a><span class="k">def</span> <span class="nf">resume_tpgfi_feature_extraxtion</span><span class="p">(</span><span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
     <span class="n">properties4lineaged_vertex</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">property_as_real</span> <span class="o">=</span> <span class="bp">True</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tpg</span> <span class="o">=</span> <span class="n">tpgfi_tracker_loader</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">ppty_already_computed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tpg</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">())</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">tpg</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">())</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">tpg</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">())</span>
    <span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">ppty_already_computed</span><span class="p">))</span>
    <span class="k">print</span> <span class="s">&quot;# -- Adding spatio-temporal features to the Spatio-Temporal Graph...&quot;</span>
    <span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="n">check_properties</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties4lineaged_vertex</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">properties4lineaged_vertex</span> <span class="o">==</span> <span class="s">&#39;strict&#39;</span><span class="p">:</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="n">tpg</span><span class="o">.</span><span class="n">lineaged_vertex</span><span class="p">(</span><span class="n">fully_lineaged</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="n">tpg</span><span class="o">.</span><span class="n">lineaged_vertex</span><span class="p">(</span><span class="n">fully_lineaged</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">tpg</span> <span class="o">=</span> <span class="n">_spatial_properties_from_images</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">)</span>

    <span class="n">tpg</span> <span class="o">=</span> <span class="n">_temporal_properties_from_images</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span>

    <span class="k">return</span> <span class="n">graph</span>
</div>
<span class="n">spatio_temporal_properties2D</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;barycenter&#39;</span><span class="p">,</span><span class="s">&#39;boundingbox&#39;</span><span class="p">,</span><span class="s">&#39;border&#39;</span><span class="p">,</span><span class="s">&#39;L1&#39;</span><span class="p">,</span><span class="s">&#39;epidermis_surface&#39;</span><span class="p">,</span><span class="s">&#39;inertia_axis&#39;</span><span class="p">]</span>
<div class="viewcode-block" id="graph_from_image2D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.graph_from_image2D">[docs]</a><span class="k">def</span> <span class="nf">graph_from_image2D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">,</span>
                     <span class="n">property_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_graph_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">,</span>
                            <span class="n">property_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>

</div>
<span class="n">spatio_temporal_properties3D</span> <span class="o">=</span> <span class="n">availables_properties</span><span class="p">()</span>
<div class="viewcode-block" id="graph_from_image3D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.graph_from_image3D">[docs]</a><span class="k">def</span> <span class="nf">graph_from_image3D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">,</span>
                     <span class="n">property_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_graph_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">,</span>
                            <span class="n">property_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="tpgfi_tracker_check"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.tpgfi_tracker_check">[docs]</a><span class="k">def</span> <span class="nf">tpgfi_tracker_check</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">images</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the tpgfi process running is related to the one temporarily saved on the disk.</span>
<span class="sd">    It does so by checking filenames of the images.</span>
<span class="sd">    :Parameters:</span>
<span class="sd">     - `obj` (list) : list of objects [analysis, labels, background, neighborhood, graphs, label2vertex, edges];</span>
<span class="sd">     - `images` (str|SpatialImage|AbstractSpatialImageAnalysis) : images used to build the TPG.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;# - Verifying tpgfi_tracker data...&quot;</span><span class="p">,</span>
    <span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span>  <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">graphs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">label2vertex</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">&quot;Done! Status: UN-USABLE. &quot;</span><span class="p">,</span>
        <span class="k">print</span> <span class="s">&quot;Lengths of &#39;analysis&#39;, &#39;labels&#39;, &#39;background&#39;, &#39;neighborhood&#39;, &#39;graphs&#39;, &#39;label2vertex&#39; and &#39;edges&#39; variables are not equal.&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">img_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">img_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">):</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s">&quot;filename&quot;</span><span class="p">]</span>
            <span class="n">img_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fname</span><span class="o">.</span><span class="n">splitext</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
            <span class="n">img_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Unable to recognise objects types from your `images` list: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">sum</span><span class="p">([</span><span class="n">name</span> <span class="o">==</span> <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img_names</span><span class="p">)])</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Done! Status: UN-USABLE.&quot;</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img_names</span><span class="p">):</span>
            <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;==&quot;</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="k">else</span> <span class="s">&quot;!=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Done! Status: USABLE.&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="tpgfi_tracker_save"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.tpgfi_tracker_save">[docs]</a><span class="k">def</span> <span class="nf">tpgfi_tracker_save</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used to save temporary TPG during &#39;temporal_graph_from_image&#39; (long) process.</span>
<span class="sd">    :Parameters:</span>
<span class="sd">     - `obj` (list) : list of objects</span>
<span class="sd">     - `filename` (str) : filename under which to save the temporary TPG.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;- Saving the tpg_temporary file {}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>  <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;Done in {}s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t_start</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="tpgfi_tracker_loader"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.tpgfi_tracker_loader">[docs]</a><span class="k">def</span> <span class="nf">tpgfi_tracker_loader</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used to load temporary TPG created during &#39;temporal_graph_from_image&#39; process.</span>
<span class="sd">    :Parameters:</span>
<span class="sd">     - `obj` (list) : list of objects</span>
<span class="sd">     - `filename` (str) : filename under which the temporary TPG is saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os.path</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;FAILED, file not found!&quot;</span>
        <span class="k">return</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&quot;- Openning the tpg_temporary file {}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">obj_list</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&quot;Done in {}s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t_start</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obj_list</span>
</div>
<div class="viewcode-block" id="tpgfi_tracker_remove"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.tpgfi_tracker_remove">[docs]</a><span class="k">def</span> <span class="nf">tpgfi_tracker_remove</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove temporary files if not adequate !</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">re</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;Temporary file &#39;{}&#39; removed !&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="temporal_graph_from_image"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.temporal_graph_from_image">[docs]</a><span class="k">def</span> <span class="nf">temporal_graph_from_image</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">lineages</span><span class="p">,</span> <span class="n">time_steps</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">background</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
     <span class="n">properties4lineaged_vertex</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">property_as_real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function creating a TemporalPropertyGraph based on a list of SpatialImages and list of lineage.</span>
<span class="sd">    Optional parameter can be provided, see below.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `images` (list) : list of images;</span>
<span class="sd">     - `lineages` (list) : list of lineages;</span>
<span class="sd">     - `time_steps` (list) : time steps between images;</span>
<span class="sd">     - `list_labels` (list) : list of labels (list) to use in each spatial graph;</span>
<span class="sd">     - `background` (int|list) : label or list of labels (list) to use as background during `SpatialImageAnalysis`;</span>
<span class="sd">     - `spatio_temporal_properties` (list) : list of strings related to spatio-temporal properties to compute;</span>
<span class="sd">     - `properties4lineaged_vertex` (bool|str) : if `False` compute properties for every possible vertex, if `True` for lineaged vertex only and if `strict` vertices temporally linked from the beginning to the end;</span>
<span class="sd">     - `property_as_real` (bool) : specify if the computed spatio-temporal properties should be return in real-world units;</span>

<span class="sd">    :**kwargs:</span>
<span class="sd">     - `min_contact_surface` (float) : minimum VOXEL surface to consider two cells as in contact;</span>
<span class="sd">     - `real_min_contact_surface` (float) : minimum REAL-WORLD surface to consider two cells as in contact;</span>
<span class="sd">     - `filename` (str) : filename used during the computation process to save temporary progression of the TPG creation;</span>
<span class="sd">     - `register_images` (bool) : boolean conditioning the registration of the images using the barycenter of lineaged cells;</span>
<span class="sd">     - `reference_image` (int|list) : if int, will register the other images on this one, if list give the order in with to do the registration (the first one being the initial reference);</span>
<span class="sd">     - `` () : ;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineages</span><span class="p">)</span> <span class="o">==</span> <span class="n">nb_images</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)</span> <span class="o">==</span> <span class="n">nb_images</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">background</span> <span class="o">=</span> <span class="p">[</span><span class="n">background</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="p">)</span> <span class="o">==</span> <span class="n">nb_images</span>

    <span class="n">images_nopath</span> <span class="o">=</span> <span class="p">[</span><span class="n">im</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="n">path_images</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s">&quot;/&quot;</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">path_images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">p_im</span> <span class="k">for</span> <span class="n">p_im</span> <span class="ow">in</span> <span class="n">path_images</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path_images</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">path_images</span> <span class="o">=</span> <span class="n">path_images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># - Recovering **kwargs:</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;min_contact_surface&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">real_surface</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;real_min_contact_surface&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">real_surface</span> <span class="o">=</span> <span class="n">property_as_real</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tmp_filename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;tmp_fname&#39;</span><span class="p">]</span>
        <span class="n">tmp_filename</span> <span class="o">=</span> <span class="s">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_filename</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c"># remove the extension (last dot-separated piece of the string, if any)</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="n">tmp_filename</span> <span class="o">=</span> <span class="s">&quot;tmp_tpgfi_process&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SpatialImage</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>

    <span class="n">try_loading</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">print</span> <span class="s">&quot;You asked to create a Spatio-Temporal Property Graph using the following {} images: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_images</span><span class="p">,</span> <span class="n">images_nopath</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;The path{} containing the images and the temporary saved steps {}: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&#39;s&#39;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_images</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;are&#39;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_images</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;is&#39;</span><span class="p">,</span> <span class="n">path_images</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;The TPG will be temporarilly saved under &#39;{}+[&#39;_step1&#39;,&#39;_step2&#39;,&#39;_graph&#39;].pkl&#39; during the creation process.</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c">### ----- STEP #1: AbstractSpatialImageAnalysis &amp; Spatial Graphs creation ----- ###</span>
    <span class="k">print</span> <span class="s">&quot;## ---- AbstractSpatialImageAnalysis &amp; Spatial Graphs creation ---- ##&quot;</span>
    <span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;# -- Trying to retreive previously computed AbstractSpatialImageAnalysis using temporary backup &#39;{}_step1.pkl&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_filename</span><span class="p">)</span>
        <span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">tpgfi_tracker_loader</span><span class="p">(</span><span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_step1.pkl&quot;</span><span class="p">)</span>
        <span class="c"># Now check the adequacy of the loaded objects (compare &#39;images&#39; filenames) with the current computation and remove the temporary file otherwise, before &#39;failing&#39; the &#39;try test&#39;...</span>
        <span class="n">correct_tmp_tpgfi</span> <span class="o">=</span> <span class="n">tpgfi_tracker_check</span><span class="p">([</span><span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span><span class="p">],</span> <span class="n">images</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">correct_tmp_tpgfi</span><span class="p">):</span> 
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;step1&quot;</span><span class="p">,</span><span class="s">&quot;step2&quot;</span><span class="p">,</span><span class="s">&quot;graph&quot;</span><span class="p">]:</span>
                <span class="n">tpgfi_tracker_remove</span><span class="p">(</span><span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_&quot;</span><span class="o">+</span><span class="n">step</span><span class="o">+</span><span class="s">&quot;.pkl&quot;</span><span class="p">)</span>
            <span class="n">try_loading</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">assert</span> <span class="n">try_loading</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s"># -- Creating Spatial Graphs...&quot;</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;# - Initialising SpatialImageAnalysis #{}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="c"># - First we contruct an object `analysis` from class `AbstractSpatialImageAnalysis`</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">imread</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">):</span>
                <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
                <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to create `SpatialImageAnalysis` objects from your `images` list, please check!&quot;</span><span class="p">)</span>

            <span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">background</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span> <span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">background</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="c"># -- Now we construct the Spatial Graph (topology):</span>
            <span class="n">neighborhood</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
            <span class="n">graphs</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">label2vertex</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_graph_topology</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">neighborhood</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="c"># - End of step 1, updating tpgfi_tracker:</span>
        <span class="n">tpgfi_tracker_save</span><span class="p">([</span><span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span><span class="p">],</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_step1.pkl&quot;</span><span class="p">)</span>


    <span class="c">### ----- Temporal_Property_Graph initialisation ----- ###</span>
    <span class="k">print</span> <span class="s">&quot;# -- Spatio-Temporal Graph initialisation...&quot;</span>
    <span class="c"># -- Now we construct the Temporal Property Graph (with no properties attached to vertex):</span>
    <span class="n">tpg</span> <span class="o">=</span> <span class="n">TemporalPropertyGraph</span><span class="p">()</span>
    <span class="n">tpg</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">graph</span> <span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="n">lineages</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">)</span>
    <span class="n">tpg</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&#39;min_contact_surface&#39;</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>
    <span class="n">tpg</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&#39;real_min_contact_surface&#39;</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Done</span><span class="se">\n\n</span><span class="s">&quot;</span>


    <span class="c">### ----- STEP #2: Images registration ----- ###</span>
    <span class="k">print</span> <span class="s">&quot;## ---- Images registration ---- ##&quot;</span>
    <span class="k">if</span> <span class="s">&#39;register_images&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;register_images&#39;</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">try_loading</span>
            <span class="k">print</span> <span class="s">&quot;# -- Trying to retreive the previous REGISTERED AbstractSpatialImageAnalysis and Spatio-Temporal Graph using temporary backup &#39;{}_step2.pkl&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_filename</span><span class="p">)</span>
            <span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">tpg</span> <span class="o">=</span> <span class="n">tpgfi_tracker_loader</span><span class="p">(</span><span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_step2.pkl&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c"># -- Registration step:</span>
            <span class="k">print</span> <span class="s">&quot;# -- Images registration...&quot;</span>
            <span class="c"># - By default we register every images onto the previous one, starting with the last one.</span>
            <span class="n">ref_images_ids_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tpg</span><span class="o">.</span><span class="n">nb_time_points</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">unreg_images_ids_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_images_ids_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c"># - If a reference image id is given or a sequence (list) of references:</span>
            <span class="k">if</span> <span class="s">&#39;reference_image&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwarg</span><span class="p">[</span><span class="s">&#39;reference_image&#39;</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span>
                    <span class="n">ref_image</span> <span class="o">=</span>  <span class="n">kwarg</span><span class="p">[</span><span class="s">&#39;reference_image&#39;</span><span class="p">]</span>
                    <span class="n">unreg_images_ids_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tpg</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">ref_image</span><span class="p">])</span> <span class="p">)</span>
                    <span class="n">ref_images_ids_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ref_images</span><span class="p">,</span> <span class="n">tpg</span><span class="o">.</span><span class="n">nb_time_points</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwarg</span><span class="p">[</span><span class="s">&#39;reference_image&#39;</span><span class="p">],</span><span class="nb">list</span><span class="p">):</span>
                    <span class="n">unreg_images_ids_list</span> <span class="o">=</span>  <span class="n">kwarg</span><span class="p">[</span><span class="s">&#39;reference_image&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">tpg</span><span class="o">.</span><span class="n">nb_time_points</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ref_images_ids_list</span> <span class="o">=</span>  <span class="n">kwarg</span><span class="p">[</span><span class="s">&#39;reference_image&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">tpg</span><span class="o">.</span><span class="n">nb_time_points</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_images_ids_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">tpg</span><span class="o">.</span><span class="n">nb_time_points</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;You asked for a registration, but I did not understood the provided kwarg &#39;reference_image&#39;.&quot;</span><span class="p">)</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Using the default order: sequential registration starting from the last time-point.&quot;</span><span class="p">)</span>

            <span class="n">reg_neighborhood</span><span class="p">,</span> <span class="n">excluded_labels</span><span class="p">,</span> <span class="n">wall_surfaces</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ref_img_id</span><span class="p">,</span> <span class="n">unreg_img_id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_images_ids_list</span><span class="p">,</span><span class="n">unreg_images_ids_list</span><span class="p">):</span>
                <span class="c"># - we save previously &#39;ignored_labels&#39;:</span>
                <span class="n">excluded_labels</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">]</span><span class="o">.</span><span class="n">ignoredlabels</span><span class="p">()</span>
                <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">- Registering image #{} over {}image #{} ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unreg_img_id</span><span class="p">,</span> <span class="s">&quot;reference &quot;</span> <span class="k">if</span> <span class="n">ref_img_id</span><span class="o">==</span><span class="n">tpg</span><span class="o">.</span><span class="n">nb_time_points</span> <span class="k">else</span> <span class="s">&quot;registered &quot;</span><span class="p">,</span> <span class="n">ref_img_id</span><span class="p">)</span>
                <span class="c"># we use only cells that are fully lineaged for stability reasons!</span>
                <span class="n">unreg_img_vids</span> <span class="o">=</span> <span class="n">tpg</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">unreg_img_id</span><span class="p">,</span> <span class="n">fully_lineaged</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
                <span class="c"># translation into SpatialImage ids:</span>
                <span class="n">unreg_SpI_ids</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">unreg_img_vids</span><span class="p">)</span>
                <span class="c"># we now need the barycenters of the &#39;fused daughter&#39;:</span>
                <span class="n">fused_siblings_bary</span> <span class="o">=</span> <span class="n">find_daugthers_barycenters</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">analysis</span><span class="p">[</span><span class="n">ref_img_id</span><span class="p">],</span> <span class="n">ref_img_id</span><span class="p">,</span> <span class="n">unreg_img_id</span><span class="p">,</span> <span class="n">unreg_img_vids</span><span class="p">)</span>
                <span class="c"># registration and resampling step:</span>
                <span class="n">ref_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">fused_siblings_bary</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fused_siblings_bary</span><span class="p">]</span>
                <span class="n">reg_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">analysis</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">]</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">unreg_SpI_ids</span><span class="p">)[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fused_siblings_bary</span><span class="p">]</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Image interpolation within the registred frame...&quot;</span><span class="p">)</span>
                <span class="n">registered_img</span> <span class="o">=</span> <span class="n">image_registration</span><span class="p">(</span><span class="n">analysis</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">ref_points</span><span class="p">,</span> <span class="n">reg_points</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">analysis</span><span class="p">[</span><span class="n">ref_img_id</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="c"># redoing the `SpatialImageAnalysis`</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Recomputing a `SpatialImageAnalysis` based on the registered image...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unreg_img_id</span><span class="p">))</span>
                <span class="n">analysis</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">registered_img</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="n">analysis</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">]</span><span class="o">.</span><span class="n">add2ignoredlabels</span><span class="p">(</span><span class="n">excluded_labels</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">])</span>
                <span class="c"># -- Now we RE-construct the Spatial Graph (topology):</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
                <span class="n">neighborhood</span><span class="p">[</span><span class="n">unreg_img_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
                <span class="n">graphs</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">label2vertex</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_graph_topology</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">neighborhood</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

            <span class="c"># -- Re-creating Spatio-Temporal Graph after registration...</span>
            <span class="k">print</span> <span class="s">&quot;# -- Re-creating the Spatio-Temporal Graph after registration...&quot;</span>
            <span class="n">tpg</span> <span class="o">=</span> <span class="n">TemporalPropertyGraph</span><span class="p">()</span>
            <span class="n">tpg</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">graph</span> <span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="n">lineages</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">)</span>
            <span class="n">tpg</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&#39;min_contact_surface&#39;</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>
            <span class="n">tpg</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&#39;real_min_contact_surface&#39;</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

            <span class="c"># - End of step 2, updating tpgfi_tracker:</span>
            <span class="n">tpgfi_tracker_save</span><span class="p">([</span><span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">tpg</span><span class="p">],</span> <span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_step2.pkl&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Not required by the user...&quot;</span>

    <span class="c">### ----- STEP #3: Cell features extraction ----- ###</span>
    <span class="c"># -- Adding spatio-temporal features to the Spatio-Temporal Graph...</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">## ---- Adding spatio-temporal features to the Spatio-Temporal Graph ---- ##&quot;</span>
    <span class="k">print</span> <span class="s">&quot;# -- Trying to retreive the previous Spatio-Temporal Graph with Features using temporary backup &#39;{}_graph.pkl&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_filename</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">try_loading</span>
        <span class="n">analysis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">tpg</span> <span class="o">=</span> <span class="n">tpgfi_tracker_loader</span><span class="p">(</span><span class="n">tmp_filename</span><span class="o">+</span><span class="s">&quot;_graph.pkl&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="n">check_properties</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties4lineaged_vertex</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">properties4lineaged_vertex</span> <span class="o">==</span> <span class="s">&#39;strict&#39;</span><span class="p">:</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="n">tpg</span><span class="o">.</span><span class="n">lineaged_vertex</span><span class="p">(</span><span class="n">fully_lineaged</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="n">tpg</span><span class="o">.</span><span class="n">lineaged_vertex</span><span class="p">(</span><span class="n">fully_lineaged</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s"># -- Computing the SPATIAL features...&quot;</span>
    <span class="n">tpg</span> <span class="o">=</span> <span class="n">_spatial_properties_from_images</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="p">)</span>

    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s"># -- Computing the TEMPORAL features...&quot;</span>
    <span class="n">tpg</span> <span class="o">=</span> <span class="n">_temporal_properties_from_images</span><span class="p">(</span><span class="n">tpg</span><span class="p">,</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span>

    <span class="k">return</span> <span class="n">tpg</span>
</div>
<div class="viewcode-block" id="label2vertex_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.label2vertex_map">[docs]</a><span class="k">def</span> <span class="nf">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map label to vertex id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; vertex property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">TemporalPropertyGraph</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">time_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">time_point</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
</div>
<div class="viewcode-block" id="vertex2label_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.vertex2label_map">[docs]</a><span class="k">def</span> <span class="nf">vertex2label_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map label to vertex id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; vertex property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">TemporalPropertyGraph</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">time_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;index&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">time_point</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
</div>
<div class="viewcode-block" id="label2vertex"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.label2vertex">[docs]</a><span class="k">def</span> <span class="nf">label2vertex</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate label as vertex id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; vertex property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label2vertexmap</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">label2vertexmap</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">label2vertexmap</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="labelpair2edge_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.labelpair2edge_map">[docs]</a><span class="k">def</span> <span class="nf">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map pair of old_labels to edge id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mvertex2label</span> <span class="o">=</span> <span class="n">vertex2label_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">([((</span><span class="n">mvertex2label</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">)],</span><span class="n">mvertex2label</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)]),</span><span class="n">eid</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">mvertex2label</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">))</span> <span class="ow">and</span> <span class="n">mvertex2label</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)))]</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="edge2labelpair_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.edge2labelpair_map">[docs]</a><span class="k">def</span> <span class="nf">edge2labelpair_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map pair of old_labels to edge id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mvertex2label</span> <span class="o">=</span> <span class="n">vertex2label_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">eid</span><span class="p">,</span> <span class="p">(</span><span class="n">mvertex2label</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">)],</span><span class="n">mvertex2label</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">mvertex2label</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">))</span> <span class="ow">and</span> <span class="n">mvertex2label</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)))]</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="vertexpair2edge_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.vertexpair2edge_map">[docs]</a><span class="k">def</span> <span class="nf">vertexpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map pair of vertex id to edge id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">([((</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)),</span><span class="n">eid</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>
</div>
<div class="viewcode-block" id="edge2vertexpair_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.edge2vertexpair_map">[docs]</a><span class="k">def</span> <span class="nf">edge2vertexpair_map</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map pair of vertex id to edge id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">eid</span><span class="p">,(</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)))</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>

</div>
<div class="viewcode-block" id="add_vertex_property_from_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_vertex_property_from_dictionary">[docs]</a><span class="k">def</span> <span class="nf">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as by a dictionary where keys are vertex labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">TemporalPropertyGraph</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">time_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">mlabel2vertex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Existing vertex property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">])</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="add_vertex_property_from_label_and_value"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_vertex_property_from_label_and_value">[docs]</a><span class="k">def</span> <span class="nf">add_vertex_property_from_label_and_value</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">property_values</span><span class="p">,</span> <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as two lists.</span>
<span class="sd">        First one gives the label in the image and second gives the value of the property.</span>
<span class="sd">        Labels are first translated in id of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mlabel2vertex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Existing vertex property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">property_values</span><span class="p">)]))</span>
</div>
<div class="viewcode-block" id="add_vertex_property_from_label_property"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_vertex_property_from_label_property">[docs]</a><span class="k">def</span> <span class="nf">add_vertex_property_from_label_property</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">label_property</span><span class="p">,</span> <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as a dictionnary associating a label and a value.</span>
<span class="sd">        Labels are first translated in id of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mlabel2vertex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Existing vertex property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">label_property</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]))</span>
</div>
<div class="viewcode-block" id="add_edge_property_from_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_edge_property_from_dictionary">[docs]</a><span class="k">def</span> <span class="nf">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as by a dictionary where keys are vertex labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mlabelpair2edge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="n">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Existing edge property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">mlabelpair2edge</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">])</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="add_edge_property_from_eid_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_edge_property_from_eid_dictionary">[docs]</a><span class="k">def</span> <span class="nf">add_edge_property_from_eid_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as by a dictionary where keys are vertex labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Existing edge property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="add_edge_property_from_label_and_value"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_edge_property_from_label_and_value">[docs]</a><span class="k">def</span> <span class="nf">add_edge_property_from_label_and_value</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">label_pairs</span><span class="p">,</span> <span class="n">property_values</span><span class="p">,</span> <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as two lists.</span>
<span class="sd">        First one gives the pair of labels in the image that are connected and the second list gives the value of the property.</span>
<span class="sd">        Pairs of labels are first translated in edge ids of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mlabelpair2edge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="n">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Existing edge property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabelpair2edge</span><span class="p">[</span><span class="n">labelpair</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">labelpair</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">label_pairs</span><span class="p">,</span><span class="n">property_values</span><span class="p">)]))</span>
</div>
<div class="viewcode-block" id="add_edge_property_from_label_property"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_edge_property_from_label_property">[docs]</a><span class="k">def</span> <span class="nf">add_edge_property_from_label_property</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">labelpair_property</span><span class="p">,</span> <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as a dictionnary associating a pair of label and a value.</span>
<span class="sd">        Pairs of labels are first translated in edge ids of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mlabelpair2edge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="n">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Existing edge property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabelpair2edge</span><span class="p">[</span><span class="n">labelpair</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">labelpair</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">labelpair_property</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]))</span>
</div>
<div class="viewcode-block" id="extend_edge_property_from_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.extend_edge_property_from_dictionary">[docs]</a><span class="k">def</span> <span class="nf">extend_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as by a dictionary where keys are vertex labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">TemporalPropertyGraph</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">time_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">mlabelpair2edge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="n">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">missing_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">mlabelpair2edge</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">if</span> <span class="n">missing_edges</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Error found while saving edge property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The provided TemporalPropertyGraph did not contain an edge between vertices: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing_edges</span><span class="p">))</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">mlabelpair2edge</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mlabelpair2edge</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="extend_vertex_property_from_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.extend_vertex_property_from_dictionary">[docs]</a><span class="k">def</span> <span class="nf">extend_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">time_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as by a dictionary where keys are vertex labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">TemporalPropertyGraph</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">time_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">mlabel2vertex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">():</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">missing_vertex</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">mlabel2vertex</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">if</span> <span class="n">missing_vertex</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Error found while saving vertex property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The provided TemporalPropertyGraph did not contain the following vert{}: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;ices&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_vertex</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span> <span class="k">else</span> <span class="s">&quot;ex&quot;</span><span class="p">,</span> <span class="n">missing_vertex</span><span class="p">))</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mlabel2vertex</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="extend_graph_property_from_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.extend_graph_property_from_dictionary">[docs]</a><span class="k">def</span> <span class="nf">extend_graph_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&quot;Adding graph_property &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="add_property2graph"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.add_property2graph">[docs]</a><span class="k">def</span> <span class="nf">add_property2graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">vids</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">property_as_real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Allow to add a property &#39;spatio_temporal_properties&#39; to an existing `TemporalPropertyGraph` &#39;graph&#39;.</span>
<span class="sd">    :Parameters:</span>
<span class="sd">     - `graph` (TemporalPropertyGraph) - graph to complete</span>
<span class="sd">     - `images` (list) - list of strings, SpatialImages or AbstractSpatialImageAnalysis to compute properties from</span>
<span class="sd">     - `spatio_temporal_properties` (list) - list of strings related to spatio-temporal properties to compute</span>
<span class="sd">     - `vids` (list) - list of vids for which to compute extra properties, if `None` use all lineaged vertex</span>
<span class="sd">     - `background` (int|list) - id or list of id specifying the background labels in each `images`</span>
<span class="sd">     - `property_as_real` (bool) - specify if the computed spatio-temporal properties should be return in real-world units</span>
<span class="sd">     - `bbox_as_real` (bool) - specify if the (cells) bounding boxes should be return in real-world units</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">ppt</span> <span class="ow">in</span> <span class="n">spatio_temporal_properties</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ppt</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ppt</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">()</span> <span class="ow">or</span> <span class="n">ppt</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">()):</span>
            <span class="k">print</span> <span class="s">&quot;The property &#39;{}&#39; is already in the graph !!!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ppt</span><span class="p">)</span>
            <span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ppt</span><span class="p">))</span>
    <span class="c"># - Nothing to do if nothing left to compute !!</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;Nothing to do if nothing left to compute !!&quot;</span>

    <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">background</span> <span class="o">=</span> <span class="p">[</span><span class="n">background</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="p">)</span> <span class="o">==</span> <span class="n">nb_images</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spatio_temporal_properties</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SpatialImage</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>

    <span class="k">print</span> <span class="s">&quot;# -- Creating Spatial Graphs...&quot;</span>
    <span class="n">analysis</span><span class="p">,</span> <span class="n">neighborhood</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Initialising SpatialImageAnalysis #{}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c"># - First we contruct an object `analysis` from class `AbstractSpatialImageAnalysis`</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">imread</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">SpatialImage</span><span class="p">):</span>
            <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
            <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span>
        <span class="c"># -- Now we re-construct the neighborhood (topology):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">translate_ids_Graph2Image</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_at_time</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;min_contact_surface&#39;</span><span class="p">)</span>
            <span class="n">real_surface</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;real_min_contact_surface&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_contact_surface</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_contact_surface</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">real_surface</span> <span class="o">=</span> <span class="n">property_as_real</span>
        <span class="n">neighborhood</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>

    <span class="c"># -- Adding spatio-temporal features to the Spatio-Temporal Graph...</span>
    <span class="k">print</span> <span class="s">&quot;# -- Adding spatio-temporal features to the Spatio-Temporal Graph...&quot;</span>
    <span class="n">spatio_temporal_properties</span> <span class="o">=</span> <span class="n">check_properties</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">spatio_temporal_properties</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vids</span> <span class="o">==</span> <span class="s">&#39;strict&#39;</span><span class="p">:</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">lineaged_vertex</span><span class="p">(</span><span class="n">fully_lineaged</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">vids</span>  <span class="o">==</span> <span class="s">&#39;lineaged&#39;</span><span class="p">:</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">lineaged_vertex</span><span class="p">(</span><span class="n">fully_lineaged</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">vids</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vids</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">_spatial_properties_from_images</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">)</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">_temporal_properties_from_images</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">vids</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span>
         <span class="n">spatio_temporal_properties</span><span class="p">,</span> <span class="n">property_as_real</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span>

    <span class="k">return</span> <span class="n">graph</span>
</div>
<div class="viewcode-block" id="retrieve_label_neighbors"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.temporal_graph_from_image.retrieve_label_neighbors">[docs]</a><span class="k">def</span> <span class="nf">retrieve_label_neighbors</span><span class="p">(</span><span class="n">SpI_Analysis</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">labelset</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">SpI_Analysis</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">,</span> <span class="n">real_surface</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span><span class="o">-</span><span class="n">labelset</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">OpenAlea community website</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, INRIA VirtualPlants.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3a0.
    </div>
  </body>
</html>