<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>image.algo.graph_from_image &mdash; OpenAlea community website</title>
    
    <link rel="stylesheet" href="../../../_static/virtualplants.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenAlea community website" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">OpenAlea community website</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for image.algo.graph_from_image</h1><div class="highlight"><pre>
<span class="c"># -*- python -*-</span>
<span class="c">#</span>
<span class="c">#       OpenAlea.image.algo</span>
<span class="c">#</span>
<span class="c">#       Copyright 2012 INRIA - CIRAD - INRA</span>
<span class="c">#</span>
<span class="c">#       File author(s):  Jonathan Legrand &lt;jonathan.legrand@ens-lyon.fr&gt;</span>
<span class="c">#                        Frederic Boudon &lt;frederic.boudon@cirad.fr&gt;</span>
<span class="c">#</span>
<span class="c">#       Distributed under the Cecill-C License.</span>
<span class="c">#       See accompanying file LICENSE.txt or copy at</span>
<span class="c">#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html</span>
<span class="c">#</span>
<span class="c">#       OpenAlea WebSite: http://openalea.gforge.inria.fr</span>
<span class="c">#</span>
<span class="c">################################################################################</span>
<span class="sd">&quot;&quot;&quot;This module helps to create PropertyGraph from SpatialImages.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">SpatialImageAnalysis</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">,</span> <span class="n">DICT</span>
<span class="kn">from</span> <span class="nn">openalea.image.spatial_image</span> <span class="kn">import</span> <span class="n">is2D</span>
<span class="kn">from</span> <span class="nn">openalea.container</span> <span class="kn">import</span> <span class="n">PropertyGraph</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c">#~ default_properties2D = [&#39;barycenter&#39;,&#39;boundingbox&#39;,&#39;border&#39;,&#39;L1&#39;,&#39;epidermis_surface&#39;,&#39;wall_surface&#39;,&#39;inertia_axis&#39;]</span>
<span class="n">default_properties2D</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;barycenter&#39;</span><span class="p">,</span><span class="s">&#39;boundingbox&#39;</span><span class="p">,</span><span class="s">&#39;border&#39;</span><span class="p">,</span><span class="s">&#39;L1&#39;</span><span class="p">,</span><span class="s">&#39;epidermis_surface&#39;</span><span class="p">,</span><span class="s">&#39;inertia_axis&#39;</span><span class="p">]</span>
<span class="n">default_properties3D</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;volume&#39;</span><span class="p">,</span><span class="s">&#39;barycenter&#39;</span><span class="p">,</span><span class="s">&#39;boundingbox&#39;</span><span class="p">,</span><span class="s">&#39;border&#39;</span><span class="p">,</span><span class="s">&#39;L1&#39;</span><span class="p">,</span><span class="s">&#39;epidermis_surface&#39;</span><span class="p">,</span><span class="s">&#39;wall_surface&#39;</span><span class="p">,</span><span class="s">&#39;inertia_axis&#39;</span><span class="p">,</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span><span class="p">,</span> <span class="s">&#39;wall_median&#39;</span><span class="p">,</span> <span class="s">&#39;all_walls_orientation&#39;</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="generate_graph_topology"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.generate_graph_topology">[docs]</a><span class="k">def</span> <span class="nf">generate_graph_topology</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function generating a topological/spatial graph based on neighbors detection.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `labels` (list) - list of labels to be found in the image and added to the topological graph.</span>
<span class="sd">     - `neighborhood` (dict) - dictionary giving neighbors of each object.</span>

<span class="sd">    :Returns:</span>
<span class="sd">     - `graph` (PropertyGraph) - the topological/spatial graph.</span>
<span class="sd">     - `label2vertex` (dict) - dictionary translating labels into vertex ids (vids).</span>
<span class="sd">     - `edges` (dict) - dictionary associating an edge id to a couple of topologically/spatially related vertex.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">PropertyGraph</span><span class="p">()</span>
    <span class="n">vertex2label</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span> <span class="n">vertex2label</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">l</span>
    <span class="n">label2vertex</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">vertex2label</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>

    <span class="n">labelset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">source</span><span class="p">,</span><span class="n">targets</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">labelset</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">labelset</span><span class="p">:</span>
                    <span class="n">edges</span><span class="p">[(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">label2vertex</span><span class="p">[</span><span class="n">source</span><span class="p">],</span><span class="n">label2vertex</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vertex2label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">graph</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span>

</div>
<span class="k">def</span> <span class="nf">_graph_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">default_properties</span><span class="p">,</span>
                     <span class="n">property_as_real</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="p">,</span>
                     <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a PropertyGraph from a SpatialImage (or equivalent) representing a segmented image.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">     - `image` (SpatialImage|AbstractSpatialImageAnalysis) - image containing labeled objects | analysis of an image.</span>
<span class="sd">     - `labels` (list) - list of labels to be found in the image.</span>
<span class="sd">        If labels is None, all labels are used.</span>
<span class="sd">     - `background` (int) - label representing background.</span>
<span class="sd">     - `default_properties` (list) - the list of name of properties to create. It should be in default_properties.</span>
<span class="sd">     - `property_as_real` (bool) - If property_as_real = True, property is in real-world units else in voxels.</span>
<span class="sd">     - `bbox_as_real` (bool) - If bbox_as_real = True, bounding boxes are in real-world units else in voxels.</span>

<span class="sd">    :rtype: PropertyGraph</span>

<span class="sd">    :Examples:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; image = np.array([[1, 2, 7, 7, 1, 1],</span>
<span class="sd">                      [1, 6, 5, 7, 3, 3],</span>
<span class="sd">                      [2, 2, 1, 7, 3, 3],</span>
<span class="sd">                      [1, 1, 1, 4, 1, 1]])</span>

<span class="sd">    &gt;&gt;&gt; from openalea.image.algo.graph_from_image import graph_from_image</span>
<span class="sd">    &gt;&gt;&gt; graph = graph_from_image(image)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">image</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">analysis</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">,</span> <span class="n">background</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">analysis</span> <span class="o">=</span> <span class="n">SpatialImageAnalysis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ignoredlabels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">:</span>
        <span class="n">analysis</span><span class="o">.</span><span class="n">add2ignoredlabels</span><span class="p">(</span> <span class="n">analysis</span><span class="o">.</span><span class="n">cells_in_image_margins</span><span class="p">()</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">filter_label</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">background</span> <span class="ow">in</span> <span class="n">labels</span> <span class="p">:</span> <span class="k">del</span> <span class="n">labels</span><span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">background</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filter_label</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="p">:</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>
        <span class="c"># -- We don&#39;t want to have the &quot;outer cell&quot; (background) and &quot;removed cells&quot; (0) in the graph structure.</span>
        <span class="c"># if 0 in labels: labels.remove(0)</span>
        <span class="k">if</span> <span class="n">background</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span> <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">background</span><span class="p">)</span>
        <span class="c"># -- If labels are provided, we ignore all others by default:</span>
        <span class="n">analysis</span><span class="o">.</span><span class="n">add2ignoredlabels</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="n">min_contact_surface</span><span class="p">)</span>
    <span class="n">labelset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="n">graph</span><span class="p">,</span> <span class="n">label2vertex</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">generate_graph_topology</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">)</span>

    <span class="c"># -- We want to keep the unit system of each variable</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&quot;units&quot;</span><span class="p">,</span><span class="nb">dict</span><span class="p">())</span>

    <span class="k">if</span> <span class="p">(</span><span class="s">&quot;wall_orientation&quot;</span> <span class="ow">in</span> <span class="n">default_properties</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;all_wall_orientation&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span><span class="p">):</span>
        <span class="n">default_properties</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&quot;wall_orientation&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;boundingbox&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Extracting boundingbox...&#39;</span>
        <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;boundingbox&#39;</span><span class="p">,</span><span class="n">analysis</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="n">bbox_as_real</span><span class="p">),</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>
        <span class="c">#~ graph._graph_property(&quot;units&quot;).update( {&quot;boundingbox&quot;:(u&#39;\xb5m&#39;if bbox_as_real else &#39;voxels&#39;)} )</span>

    <span class="k">if</span> <span class="s">&#39;volume&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="ow">and</span> <span class="n">analysis</span><span class="o">.</span><span class="n">is3D</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&#39;Computing volume property...&#39;</span>
        <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;volume&#39;</span><span class="p">,</span><span class="n">analysis</span><span class="o">.</span><span class="n">volume</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">),</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>
        <span class="c">#~ graph._graph_property(&quot;units&quot;).update( {&quot;volume&quot;:(u&#39;\xb5m\xb3&#39;if property_as_real else &#39;voxels&#39;)} )</span>

    <span class="n">barycenters</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="s">&#39;barycenter&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing barycenter property...&#39;</span>
        <span class="n">barycenters</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">)</span>
        <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;barycenter&#39;</span><span class="p">,</span><span class="n">barycenters</span><span class="p">,</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>
        <span class="c">#~ graph._graph_property(&quot;units&quot;).update( {&quot;barycenter&quot;:(u&#39;\xb5m&#39;if property_as_real else &#39;voxels&#39;)} )</span>

    <span class="n">background_neighbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">background</span><span class="p">))</span>
    <span class="n">background_neighbors</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">labelset</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">&#39;L1&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Generating the list of cells belonging to the first layer...&#39;</span>
        <span class="n">add_vertex_property_from_label_and_value</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;L1&#39;</span><span class="p">,</span><span class="n">labels</span><span class="p">,[(</span><span class="n">l</span> <span class="ow">in</span> <span class="n">background_neighbors</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">],</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;border&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Generating the list of cells at the margins of the stack...&#39;</span>
        <span class="n">border_cells</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">cells_in_image_margins</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span> <span class="n">border_cells</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">background</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
        <span class="n">border_cells</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">border_cells</span><span class="p">)</span>
        <span class="n">add_vertex_property_from_label_and_value</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;border&#39;</span><span class="p">,</span><span class="n">labels</span><span class="p">,[(</span><span class="n">l</span> <span class="ow">in</span> <span class="n">border_cells</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">],</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;inertia_axis&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing inertia_axis property...&#39;</span>
        <span class="n">inertia_axis</span><span class="p">,</span> <span class="n">inertia_values</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">inertia_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">barycenters</span><span class="p">)</span>
        <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;inertia_axis&#39;</span><span class="p">,</span><span class="n">inertia_axis</span><span class="p">,</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>
        <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;inertia_values&#39;</span><span class="p">,</span><span class="n">inertia_values</span><span class="p">,</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;wall_surface&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing wall_surface property...&#39;</span>
        <span class="n">filtered_edges</span><span class="p">,</span> <span class="n">unlabelled_target</span><span class="p">,</span> <span class="n">unlabelled_wall_surfaces</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span><span class="n">targets</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">labelset</span> <span class="p">:</span>
                <span class="n">filtered_edges</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">target</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span> <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">labelset</span> <span class="p">]</span>
                <span class="n">unlabelled_target</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">target</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span> <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labelset</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">!=</span> <span class="n">background</span><span class="p">]</span>
        <span class="n">wall_surfaces</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">wall_surfaces</span><span class="p">(</span><span class="n">filtered_edges</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">)</span>
        <span class="n">add_edge_property_from_label_property</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;wall_surface&#39;</span><span class="p">,</span><span class="n">wall_surfaces</span><span class="p">,</span><span class="n">mlabelpair2edge</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>

        <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="s">&#39;unlabelled_wall_surface&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">unlabelled_target</span><span class="p">:</span>
            <span class="n">unlabelled_wall_surface</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">wall_surfaces</span><span class="p">({</span><span class="n">source</span><span class="p">:</span><span class="n">unlabelled_target</span><span class="p">[</span><span class="n">source</span><span class="p">]},</span><span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;unlabelled_wall_surface&#39;</span><span class="p">)[</span><span class="n">label2vertex</span><span class="p">[</span><span class="n">source</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">unlabelled_wall_surface</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c">#~ graph._graph_property(&quot;units&quot;).update( {&quot;wall_surface&quot;:(&#39;\xb5m\xb2&#39;if property_as_real else &#39;voxels&#39;)} )</span>
        <span class="c">#~ graph._graph_property(&quot;units&quot;).update( {&quot;unlabelled_wall_surface&quot;:(&#39;\xb5m\xb2&#39;if property_as_real else &#39;voxels&#39;)} )</span>

    <span class="k">if</span> <span class="s">&#39;epidermis_surface&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span> <span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing epidermis_surface property...&#39;</span>
        <span class="k">def</span> <span class="nf">not_background</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">background</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">background</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span> <span class="k">return</span> <span class="n">b</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">background</span><span class="p">:</span> <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">epidermis_surfaces</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">cell_wall_surface</span><span class="p">(</span><span class="n">background</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">background_neighbors</span><span class="p">)</span> <span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="n">property_as_real</span><span class="p">)</span>
        <span class="n">epidermis_surfaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">not_background</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">indices</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">epidermis_surfaces</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
        <span class="n">add_vertex_property_from_label_property</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="s">&#39;epidermis_surface&#39;</span><span class="p">,</span><span class="n">epidermis_surfaces</span><span class="p">,</span><span class="n">mlabel2vertex</span><span class="o">=</span><span class="n">label2vertex</span><span class="p">)</span>
        <span class="c">#~ graph._graph_property(&quot;units&quot;).update( {&quot;epidermis_surface&quot;:(&#39;\xb5m\xb2&#39;if property_as_real else &#39;voxels&#39;)} )</span>


    <span class="k">if</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing projected_anticlinal_wall_median property...&#39;</span>
        <span class="n">wall_median</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dict_anticlinal_wall_voxels</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">wall_voxels_per_cells_pairs</span><span class="p">(</span> <span class="n">analysis</span><span class="o">.</span><span class="n">layer1</span><span class="p">(),</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">only_epidermis</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">ignore_background</span> <span class="o">=</span> <span class="bp">True</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_anticlinal_wall_voxels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># if 0 means that it wasn&#39;t in the labels list provided, so we skip it.</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">dict_anticlinal_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
            <span class="c"># compute geometric median:</span>
            <span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">geometric_median</span><span class="p">,</span> <span class="n">closest_from_A</span>
            <span class="n">neighborhood_origin</span> <span class="o">=</span> <span class="n">geometric_median</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">z</span><span class="p">)])</span> <span class="p">)</span>
            <span class="n">integers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">neighborhood_origin</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="n">neighborhood_origin</span><span class="p">)</span>
            <span class="c"># closest points:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">closest_from_A</span><span class="p">(</span><span class="n">neighborhood_origin</span><span class="p">,</span> <span class="n">pts</span><span class="p">)</span>
            <span class="n">wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">min_dist</span>

        <span class="n">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;projected_anticlinal_wall_median&#39;</span><span class="p">,</span> <span class="n">wall_median</span><span class="p">)</span>


    <span class="k">if</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing wall_median property...&#39;</span>
        <span class="n">dict_wall_voxels</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">wall_voxels_per_cells_pairs</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">ignore_background</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>

        <span class="n">wall_median</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_wall_voxels</span><span class="p">:</span>
            <span class="c">#~ if dict_wall_voxels[(label_1, label_2)] == None:</span>
                <span class="c">#~ if label_1 != 0:</span>
                    <span class="c">#~ print &quot;There might be something wrong between cells %d and %d&quot; %label_1  %label_2</span>
                <span class="c">#~ continue # if None we can use it.</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">dict_wall_voxels</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
            <span class="c"># compute geometric median:</span>
            <span class="kn">from</span> <span class="nn">openalea.image.algo.analysis</span> <span class="kn">import</span> <span class="n">geometric_median</span><span class="p">,</span> <span class="n">closest_from_A</span>
            <span class="n">neighborhood_origin</span> <span class="o">=</span> <span class="n">geometric_median</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">z</span><span class="p">)])</span> <span class="p">)</span>
            <span class="n">integers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">neighborhood_origin</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="n">neighborhood_origin</span><span class="p">)</span>
            <span class="c"># closest points:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">closest_from_A</span><span class="p">(</span><span class="n">neighborhood_origin</span><span class="p">,</span> <span class="n">pts</span><span class="p">)</span>
            <span class="n">wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">min_dist</span>

        <span class="n">edge_wall_median</span><span class="p">,</span> <span class="n">unlabelled_wall_median</span><span class="p">,</span> <span class="n">vertex_wall_median</span> <span class="o">=</span> <span class="p">{},{},{}</span>
        <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_wall_voxels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">label_2</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
                <span class="n">edge_wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys returned by `wall_voxels_per_cells_pairs`</span>
                <span class="n">unlabelled_wall_median</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys returned by `wall_voxels_per_cells_pairs`</span>
                <span class="n">vertex_wall_median</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">wall_median</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>

        <span class="n">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_median&#39;</span><span class="p">,</span> <span class="n">edge_wall_median</span><span class="p">)</span>
        <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_median&#39;</span><span class="p">,</span> <span class="n">vertex_wall_median</span><span class="p">)</span>
        <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_median&#39;</span><span class="p">,</span> <span class="n">unlabelled_wall_median</span><span class="p">)</span>


    <span class="k">if</span> <span class="s">&#39;all_walls_orientation&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing wall_orientation property...&#39;</span>
        <span class="c"># -- First we have to extract the voxels defining the frontier between two objects:</span>
        <span class="c"># - Extract wall_orientation property for &#39;unlabelled&#39; and &#39;epidermis&#39; walls as well:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dict_wall_voxels</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">dict_wall_voxels</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">wall_voxels_per_cells_pairs</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">neighborhood</span><span class="p">,</span> <span class="n">ignore_background</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>

        <span class="k">if</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
            <span class="n">medians_coords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edge_vertices</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="s">&#39;wall_median&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">medians_coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">vid</span><span class="p">)</span> <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;unlabelled_wall_median&#39;</span><span class="p">)</span> <span class="p">))</span>
            <span class="n">medians_coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">vid</span><span class="p">)</span> <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;epidermis_wall_median&#39;</span><span class="p">)</span> <span class="p">))</span>
            <span class="n">pc_values</span><span class="p">,</span> <span class="n">pc_normal</span><span class="p">,</span> <span class="n">pc_directions</span><span class="p">,</span> <span class="n">pc_origin</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">wall_orientation</span><span class="p">(</span> <span class="n">dict_wall_voxels</span><span class="p">,</span> <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plane_projection</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">dict_coord_points_ori</span> <span class="o">=</span> <span class="n">medians_coords</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pc_values</span><span class="p">,</span> <span class="n">pc_normal</span><span class="p">,</span> <span class="n">pc_directions</span><span class="p">,</span> <span class="n">pc_origin</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">wall_orientation</span><span class="p">(</span> <span class="n">dict_wall_voxels</span><span class="p">,</span> <span class="n">fitting_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plane_projection</span> <span class="o">=</span> <span class="bp">False</span> <span class="p">)</span>

        <span class="c"># -- Now we can compute the orientation of the frontier between two objects:</span>
        <span class="n">edge_pc_values</span><span class="p">,</span> <span class="n">edge_pc_normal</span><span class="p">,</span> <span class="n">edge_pc_directions</span><span class="p">,</span> <span class="n">edge_pc_origin</span> <span class="o">=</span> <span class="p">{},{},{},{}</span>
        <span class="n">vertex_pc_values</span><span class="p">,</span> <span class="n">vertex_pc_normal</span><span class="p">,</span> <span class="n">vertex_pc_directions</span><span class="p">,</span> <span class="n">vertex_pc_origin</span> <span class="o">=</span> <span class="p">{},{},{},{}</span>
        <span class="n">epidermis_pc_values</span><span class="p">,</span> <span class="n">epidermis_pc_normal</span><span class="p">,</span> <span class="n">epidermis_pc_directions</span><span class="p">,</span> <span class="n">epidermis_pc_origin</span> <span class="o">=</span> <span class="p">{},{},{},{}</span>
        <span class="k">for</span> <span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span> <span class="ow">in</span> <span class="n">dict_wall_voxels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">label_2</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
                <span class="n">edge_pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">edge_pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">edge_pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">edge_pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys returned by `wall_voxels_per_cells_pairs`</span>
                <span class="n">vertex_pc_values</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">vertex_pc_normal</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">vertex_pc_directions</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">vertex_pc_origin</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">label_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># no need to check `label_2` because labels are sorted in keys returned by `wall_voxels_per_cells_pairs`</span>
                <span class="n">epidermis_pc_values</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_values</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">epidermis_pc_normal</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_normal</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">epidermis_pc_directions</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_directions</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>
                <span class="n">epidermis_pc_origin</span><span class="p">[</span><span class="n">label_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_origin</span><span class="p">[(</span><span class="n">label_1</span><span class="p">,</span> <span class="n">label_2</span><span class="p">)]</span>

        <span class="n">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_values&#39;</span><span class="p">,</span> <span class="n">edge_pc_values</span><span class="p">)</span>
        <span class="n">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_normal&#39;</span><span class="p">,</span> <span class="n">edge_pc_normal</span><span class="p">)</span>
        <span class="n">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_directions&#39;</span><span class="p">,</span> <span class="n">edge_pc_directions</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
            <span class="n">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;wall_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">edge_pc_origin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertex_pc_values</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_values&#39;</span><span class="p">,</span> <span class="n">vertex_pc_values</span><span class="p">)</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_normal&#39;</span><span class="p">,</span> <span class="n">vertex_pc_normal</span><span class="p">)</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_directions&#39;</span><span class="p">,</span> <span class="n">vertex_pc_directions</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;unlabelled_wall_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">vertex_pc_origin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">epidermis_pc_values</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_values&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_values</span><span class="p">)</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_normal&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_normal</span><span class="p">)</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_directions&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_directions</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
                <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_wall_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">epidermis_pc_origin</span><span class="p">)</span>


    <span class="k">if</span> <span class="s">&#39;epidermis_local_principal_curvature&#39;</span> <span class="ow">in</span> <span class="n">default_properties</span><span class="p">:</span>
        <span class="n">index_radius</span> <span class="o">=</span> <span class="n">default_properties</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;epidermis_local_principal_curvature&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">],</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">default_properties</span><span class="p">[</span><span class="n">index_radius</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="mi">60</span><span class="p">]</span>

        <span class="n">graph</span><span class="o">.</span><span class="n">add_graph_property</span><span class="p">(</span><span class="s">&#39;radius_local_principal_curvature_estimation&#39;</span><span class="p">,</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">radius</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_property</span><span class="p">(</span><span class="s">&#39;radius_local_principal_curvature_estimation&#39;</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;Computing local_principal_curvature property with radius = {}voxels...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">u&quot;This represent a local curvature estimation area of {}</span><span class="se">\xb5</span><span class="s">m</span><span class="se">\xb2</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">radius</span><span class="o">*</span><span class="n">analysis</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">radius</span><span class="o">*</span><span class="n">analysis</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">analysis</span><span class="o">.</span><span class="n">compute_principal_curvatures</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_values_r&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">analysis</span><span class="o">.</span><span class="n">principal_curvatures</span><span class="p">)</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_normal_r&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">analysis</span><span class="o">.</span><span class="n">principal_curvatures_normal</span><span class="p">)</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_directions_r&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">analysis</span><span class="o">.</span><span class="n">principal_curvatures_directions</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;wall_median&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
            <span class="n">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&#39;epidermis_local_principal_curvature_origin&#39;</span><span class="p">,</span> <span class="n">analysis</span><span class="o">.</span><span class="n">principal_curvatures_origin</span><span class="p">)</span>

    <span class="c">#~ if &#39;local_gaussian_curvature&#39; in default_properties:</span>
        <span class="c">#~ print &#39;Computing local_gaussian_curvature with radius = {}voxels...&#39;.format(radius)</span>
        <span class="c">#~ gaussian_curvature = analysis.gaussian_curvature_CGAL(radius=radius,verbose=True)</span>
        <span class="c">#~ add_vertex_property_from_dictionary(graph, &#39;local_gaussian_curvature_r&#39;+str(radius), gaussian_curvature)</span>
<span class="c">#~</span>
    <span class="c">#~ if &#39;local_mean_curvature&#39; in default_properties:</span>
        <span class="c">#~ print &#39;Computing local_mean_curvature property with radius = {}voxels...&#39;.format(radius)</span>
        <span class="c">#~ mean_curvature = analysis.mean_curvature_CGAL(radius=radius,verbose=True)</span>
        <span class="c">#~ add_vertex_property_from_dictionary(graph, &#39;local_mean_curvature_r&#39;+str(radius), mean_curvature)</span>
<span class="c">#~</span>
    <span class="c">#~ if &#39;local_curvature_ratio&#39; in default_properties:</span>
        <span class="c">#~ print &#39;Computing local_curvature_ratio property with radius = {}voxels...&#39;.format(radius)</span>
        <span class="c">#~ curvature_ratio = analysis.curvature_ratio_CGAL(radius=radius,verbose=True)</span>
        <span class="c">#~ add_vertex_property_from_dictionary(graph, &#39;local_curvature_ratio_r&#39;+str(radius), curvature_ratio)</span>
<span class="c">#~</span>
    <span class="c">#~ if &#39;local_curvature_anisotropy&#39; in default_properties:</span>
        <span class="c">#~ print &#39;Computing local_curvature_anisotropy property with radius = {}voxels...&#39;.format(radius)</span>
        <span class="c">#~ curvature_anisotropy = analysis.curvature_anisotropy_CGAL(radius=radius,verbose=True)</span>
        <span class="c">#~ add_vertex_property_from_dictionary(graph, &#39;local_curvature_anisotropy_r&#39;+str(radius), curvature_anisotropy)</span>

    <span class="k">return</span> <span class="n">graph</span>


<div class="viewcode-block" id="graph_from_image2D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.graph_from_image2D">[docs]</a><span class="k">def</span> <span class="nf">graph_from_image2D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">default_properties</span><span class="p">,</span>
                     <span class="n">property_as_real</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="p">,</span>
                     <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_graph_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">default_properties</span><span class="p">,</span>
                            <span class="n">property_as_real</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="graph_from_image3D"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.graph_from_image3D">[docs]</a><span class="k">def</span> <span class="nf">graph_from_image3D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">default_properties</span><span class="p">,</span>
                     <span class="n">property_as_real</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="p">,</span>
                     <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_graph_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">default_properties</span><span class="p">,</span>
                            <span class="n">property_as_real</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="graph_from_image"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.graph_from_image">[docs]</a><span class="k">def</span> <span class="nf">graph_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span>
                     <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                     <span class="n">background</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">default_properties</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                     <span class="n">property_as_real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                     <span class="n">bbox_as_real</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                     <span class="n">ignore_cells_at_stack_margins</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                     <span class="n">min_contact_surface</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">AbstractSpatialImageAnalysis</span><span class="p">):</span>
        <span class="n">real_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">image</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">real_image</span> <span class="o">=</span> <span class="n">image</span>

    <span class="k">if</span> <span class="n">is2D</span><span class="p">(</span><span class="n">real_image</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">default_properties</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">default_properties</span> <span class="o">=</span> <span class="n">default_properties2D</span>
        <span class="k">return</span> <span class="n">graph_from_image2D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">default_properties</span><span class="p">,</span>
                            <span class="n">property_as_real</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">default_properties</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">default_properties</span> <span class="o">=</span> <span class="n">default_properties3D</span>
        <span class="k">return</span> <span class="n">graph_from_image3D</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">default_properties</span><span class="p">,</span>
                            <span class="n">property_as_real</span><span class="p">,</span> <span class="n">bbox_as_real</span><span class="p">,</span> <span class="n">ignore_cells_at_stack_margins</span><span class="p">,</span> <span class="n">min_contact_surface</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="label2vertex_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.label2vertex_map">[docs]</a><span class="k">def</span> <span class="nf">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map label to vertex id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; vertex property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
</div>
<div class="viewcode-block" id="label2vertex"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.label2vertex">[docs]</a><span class="k">def</span> <span class="nf">label2vertex</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">labels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate label as vertex id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; vertex property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label2vertexmap</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">label2vertexmap</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
    <span class="k">else</span> <span class="p">:</span> <span class="k">return</span> <span class="n">label2vertexmap</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="labelpair2edge_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.labelpair2edge_map">[docs]</a><span class="k">def</span> <span class="nf">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map pair of labels to edge id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">([((</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">)],</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)]),</span><span class="n">eid</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>
</div>
<div class="viewcode-block" id="vertexpair2edge_map"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.vertexpair2edge_map">[docs]</a><span class="k">def</span> <span class="nf">vertexpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dictionary that map pair of labels to edge id.</span>
<span class="sd">        It requires the existence of a &#39;label&#39; property</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">([((</span><span class="n">graph</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span><span class="n">graph</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">eid</span><span class="p">)),</span><span class="n">eid</span><span class="p">)</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>

</div>
<div class="viewcode-block" id="add_vertex_property_from_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.add_vertex_property_from_dictionary">[docs]</a><span class="k">def</span> <span class="nf">add_vertex_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as by a dictionary where keys are vertex labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mlabel2vertex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Existing vertex property </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">])</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="add_vertex_property_from_label_and_value"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.add_vertex_property_from_label_and_value">[docs]</a><span class="k">def</span> <span class="nf">add_vertex_property_from_label_and_value</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">property_values</span><span class="p">,</span> <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as two lists.</span>
<span class="sd">        First one gives the label in the image and second gives the value of the property.</span>
<span class="sd">        Labels are first translated in id of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mlabel2vertex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Existing vertex property </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">property_values</span><span class="p">)]))</span>
</div>
<div class="viewcode-block" id="add_vertex_property_from_label_property"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.add_vertex_property_from_label_property">[docs]</a><span class="k">def</span> <span class="nf">add_vertex_property_from_label_property</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">label_property</span><span class="p">,</span> <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as a dictionnary associating a label and a value.</span>
<span class="sd">        Labels are first translated in id of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mlabel2vertex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabel2vertex</span> <span class="o">=</span> <span class="n">label2vertex_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Existing vertex property </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">vertex_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabel2vertex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">label_property</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]))</span>
</div>
<div class="viewcode-block" id="add_edge_property_from_dictionary"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.add_edge_property_from_dictionary">[docs]</a><span class="k">def</span> <span class="nf">add_edge_property_from_dictionary</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as by a dictionary where keys are vertex labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mlabelpair2edge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="n">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Existing edge property </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">mlabelpair2edge</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">])</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="add_edge_property_from_label_and_value"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.add_edge_property_from_label_and_value">[docs]</a><span class="k">def</span> <span class="nf">add_edge_property_from_label_and_value</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">label_pairs</span><span class="p">,</span> <span class="n">property_values</span><span class="p">,</span> <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as two lists.</span>
<span class="sd">        First one gives the pair of labels in the image that are connected and the second list gives the value of the property.</span>
<span class="sd">        Pairs of labels are first translated in edge ids of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mlabelpair2edge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="n">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Existing edge property </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabelpair2edge</span><span class="p">[</span><span class="n">labelpair</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">labelpair</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">label_pairs</span><span class="p">,</span><span class="n">property_values</span><span class="p">)]))</span>
</div>
<div class="viewcode-block" id="add_edge_property_from_label_property"><a class="viewcode-back" href="../../../latest/dev/archi/apidoc/components/image/image.algo.html#image.algo.graph_from_image.add_edge_property_from_label_property">[docs]</a><span class="k">def</span> <span class="nf">add_edge_property_from_label_property</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">labelpair_property</span><span class="p">,</span> <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge property with name &#39;name&#39; to the graph build from an image.</span>
<span class="sd">        The values of the property are given as a dictionnary associating a pair of label and a value.</span>
<span class="sd">        Pairs of labels are first translated in edge ids of the graph and values are assigned to these ids in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mlabelpair2edge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mlabelpair2edge</span> <span class="o">=</span> <span class="n">labelpair2edge_map</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Existing edge property </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edge_property</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">mlabelpair2edge</span><span class="p">[</span><span class="n">labelpair</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">labelpair</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">labelpair_property</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">OpenAlea community website</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, INRIA VirtualPlants.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3a0.
    </div>
  </body>
</html>